{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/Hacker/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-heart.svg","path":"images/icon-heart.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/archive.styl","path":"css/components/archive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/article.styl","path":"css/components/article.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/header.styl","path":"css/components/header.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/categories.styl","path":"css/components/categories.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/footer.styl","path":"css/components/footer.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/icon.styl","path":"css/components/icon.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/layout.styl","path":"css/components/layout.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/tags.styl","path":"css/components/tags.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/syntax.styl","path":"css/components/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/pagination.styl","path":"css/components/pagination.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/responsive.styl","path":"css/components/responsive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/base/normalize.css","path":"css/base/normalize.css","modified":1,"renderable":1}],"Cache":[{"_id":"themes/Hacker/.gitignore","hash":"803c06a7086b5817c03d2e8672da27bc56ba2bce","modified":1485843797000},{"_id":"source/CNAME","hash":"d3af5b9b062d55a5445af8908c3a1671e35639a1","modified":1497240939000},{"_id":"themes/Hacker/README.md","hash":"71077f7bdebc6e8d36f763e715ec2d55ddca4141","modified":1485843797000},{"_id":"themes/Hacker/LICENSE","hash":"3127907a7623734f830e8c69ccee03b693bf993e","modified":1485843797000},{"_id":"themes/Hacker/README_zh-CN.md","hash":"d6c9200e96bb3633c3a84de169f91e6c34a5ea14","modified":1485843797000},{"_id":"themes/Hacker/_config.yml","hash":"5d8cc859c48024451a316c50ab16ba58702b062d","modified":1485843797000},{"_id":"source/_posts/front-end-engineering-practice.md","hash":"b47616ef4b929734cb5433aecb7a74ee5938c5e0","modified":1503244416000},{"_id":"source/_posts/bd_logo1.png","hash":"011387db777ff33fa46481bb4ebabbac796240a9","modified":1503080679000},{"_id":"source/_posts/渐进式全栈开发策略.md","hash":"4dc1b0717dc45b403666bea02c2e7c4a611a3ee7","modified":1498126115000},{"_id":"themes/Hacker/languages/default.yml","hash":"ef90548952b1f9cc88dbe9daad882786212aec38","modified":1485843797000},{"_id":"themes/Hacker/languages/zh-CN.yml","hash":"18638177b944e0deb4a8c26a1c4a980901151132","modified":1485843797000},{"_id":"themes/Hacker/layout/archive.ejs","hash":"2238cbe29009aafb16969d2c70dceb3f71772123","modified":1485843797000},{"_id":"themes/Hacker/layout/categories.ejs","hash":"bfad4e7eade650c535f0194974e2646619657b8b","modified":1485843797000},{"_id":"themes/Hacker/layout/index.ejs","hash":"1d2c487a95d25e763b5f7e004194eb6ee6b18135","modified":1485843797000},{"_id":"themes/Hacker/layout/layout.ejs","hash":"341e77b5f07457e4ccd69634f511da05a5d89f18","modified":1485843797000},{"_id":"themes/Hacker/layout/post.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1485843797000},{"_id":"themes/Hacker/layout/page.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1485843797000},{"_id":"themes/Hacker/layout/tags.ejs","hash":"ee89e6a9c14bdb5e5e8cf975a558c780fe8dabff","modified":1485843797000},{"_id":"themes/Hacker/layout/components/article.ejs","hash":"5a08e05eb271589a2ed69fdd08516fa8457af3ed","modified":1485843797000},{"_id":"themes/Hacker/layout/components/archive.ejs","hash":"1f79ebaf52b8229cf5c58bb8325cf0177859a05c","modified":1485843797000},{"_id":"themes/Hacker/layout/components/categories.ejs","hash":"3665bf5d1c7181db22dc1c48d62ebf42757d8c27","modified":1485843797000},{"_id":"themes/Hacker/layout/components/comment.ejs","hash":"34b72f9819b5298be101f5c568cc7f2a52ab0f7d","modified":1485843797000},{"_id":"themes/Hacker/layout/components/footer.ejs","hash":"538795f4af3a98e824aefc4b68a1bcd210c091e9","modified":1485843797000},{"_id":"themes/Hacker/layout/components/head.ejs","hash":"10475fdfc513c9380f18d034e15b3b051c8e9269","modified":1485843797000},{"_id":"themes/Hacker/layout/components/googleanalytics.ejs","hash":"fa11251ace0fc61cbcffb74f32fbf5bdbb201ff2","modified":1485843797000},{"_id":"themes/Hacker/layout/components/header.ejs","hash":"929a8eafa278d49c2f41d3581e2608eca80d7856","modified":1485843797000},{"_id":"themes/Hacker/layout/components/pagination.ejs","hash":"4ab5e3b0239e467923a0f91c771bcc9ee7889cfe","modified":1485843797000},{"_id":"themes/Hacker/source/css/style.styl","hash":"208e5f6d010e4e2c5590dae5e4fca8de592d3ef1","modified":1485843797000},{"_id":"themes/Hacker/source/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/archive.styl","hash":"de701a1dee6e870140565044a08c2c45cfcd4bc3","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/article.styl","hash":"e99f13c6744ddaa7f7bfcf0662e4dc6840fae8fa","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/header.styl","hash":"fa5e6d715d288a327406df78225284c70530cb98","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/categories.styl","hash":"c67e20d60351295cb178b568af42d430f4bcc3e6","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/footer.styl","hash":"80ef890252d31d3bbfe71740fdcfc54ae14cad8e","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/icon.styl","hash":"8da3ff5b6cd1609fdfe0c564d47391367abc8808","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/layout.styl","hash":"73c1688b95b20cd67669bc5567420f5be8448c9f","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/tags.styl","hash":"684cf4eb4b8671476365e955dceebf096cc0e6ed","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/syntax.styl","hash":"68b7deadab1ac13603eb5e812e1060db25227fd0","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/pagination.styl","hash":"c20a9920bb444c22b20e588f97eba4e03f09a439","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/responsive.styl","hash":"053e7ec4c22845422440660b7e1d6b0dea5b4fbd","modified":1485843797000},{"_id":"themes/Hacker/source/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1485843797000},{"_id":"public/2017/06/16/渐进式全栈开发策略/index.html","hash":"d2480e5e95f77ad0f2085b413fa0389e1b225ef8","modified":1503244458821},{"_id":"public/archives/index.html","hash":"580d2a93e6951b8f1f2434508377767edcdcf82b","modified":1503244458853},{"_id":"public/archives/2017/index.html","hash":"28ac53f6a11663760f4e0e7cad3716e3d1462228","modified":1503244458853},{"_id":"public/archives/2017/06/index.html","hash":"5c9edd23567352ca2b66938dbaff8c15f8c1bb81","modified":1503244458854},{"_id":"public/archives/2017/08/index.html","hash":"ce37811a04698fe10f9d13e66f0569d2fc2575f5","modified":1503244458854},{"_id":"public/tags/工程化/index.html","hash":"f7b069a25f984e16315aee9ba0a28775e23e6f12","modified":1503244458854},{"_id":"public/tags/git/index.html","hash":"4f4444d624b5045e4444137c51ab054c75b19d2e","modified":1503244458854},{"_id":"public/tags/eslint/index.html","hash":"3d839683db41cce9d7eb1e3d27761f369f861f4c","modified":1503244458854},{"_id":"public/tags/全栈/index.html","hash":"f85c553d641d299b58d7f22275cbc0a7716a67db","modified":1503244458854},{"_id":"public/tags/Node/index.html","hash":"03e8c6c87b8070471f2e9fb899bb35f20a2bca28","modified":1503244458854},{"_id":"public/2017/08/18/front-end-engineering-practice/index.html","hash":"28e6cbfb7fb93f5b1b5e8d777c3f921305a9f4e2","modified":1503244458854},{"_id":"public/index.html","hash":"eb72e1da91b35bb2f4b778bd3ee5eca3352ce49a","modified":1503244458854},{"_id":"public/tags/文档/index.html","hash":"3fb40bf9a5a1ded6ba3bee95cf52391b683c71bb","modified":1503244458859},{"_id":"public/tags/开源/index.html","hash":"d983c64a9e0bb8a297fe822dba73939a17e1a2b5","modified":1503244458859},{"_id":"public/tags/es6/index.html","hash":"31d814a9ae4900d53fd129ea582d1801d64b1120","modified":1503244458860},{"_id":"public/CNAME","hash":"d3af5b9b062d55a5445af8908c3a1671e35639a1","modified":1503244458867},{"_id":"public/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1503244458867},{"_id":"public/css/components/archive.css","hash":"14902abf01556a3e23e03ac18c87fa7a5a39d89a","modified":1503244459253},{"_id":"public/css/components/article.css","hash":"563b6fd19e1f5ba4787acd2ef2e1ee876e521cab","modified":1503244459253},{"_id":"public/css/components/header.css","hash":"51f8a4c736f3b180a7c4c8f804d8060031df6a34","modified":1503244459254},{"_id":"public/css/components/categories.css","hash":"f181d27640f1408f032c5386836c4c2322724f8d","modified":1503244459254},{"_id":"public/css/components/footer.css","hash":"602def895fd52f288b6e93932284aa2e52b7fee0","modified":1503244459254},{"_id":"public/css/components/icon.css","hash":"cdaf1a152184ff7def760f14095e4a2fa16cd6bd","modified":1503244459254},{"_id":"public/css/components/layout.css","hash":"b8625c7b90a973f2e37897f346e6f80b779fd9ca","modified":1503244459254},{"_id":"public/css/components/tags.css","hash":"1566e94c23ae19dbfc7d2cf433e68242ed657dea","modified":1503244459254},{"_id":"public/css/components/syntax.css","hash":"00970bfdb168aa13622c829920907ca3416829f8","modified":1503244459254},{"_id":"public/css/components/pagination.css","hash":"2f3f9bb1bc6513d08865e7a2fb2160cc47d4a229","modified":1503244459254},{"_id":"public/css/components/responsive.css","hash":"216eb94fc69007de995fc8d382670ba00a9574e8","modified":1503244459254},{"_id":"public/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1503244459254},{"_id":"public/css/style.css","hash":"48373889a036d403ca34bc085cabeb302e2a08ee","modified":1503244459254}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"前端工程化实践","date":"2017-08-17T16:00:00.000Z","_content":"\n# 前端工程化实践\n\n年初有幸加入到 TalkingData，到现在半年有余。\b是时候回头看看，这半年走过的路。\n\n感谢 TD 的充分信任和赋能，使我可以在团队中大胆实践和尝试。\n\n整个团队负责很多条产品线，如果技术规范和技术栈不统一，就很难保证产品的快速迭代。在这半年里，推行组件化开发理念、规范了 Git 工作流和 Git Commit message，开发语言迁移到 ES6, 并引入了 Airbnb 规范。\n\n整个前端团队，还要经历从组件化到模块化、从引入开源到生态贡献和从纯前端到大前端团队的发展道路。\n\n## 组件化\n工程师们按设计规格，制造出机器（单页应用）的零部件（组件），就可以快速组装好一部完整的机器。\n\n同样，开发团队将设计稿拆分出一个个职责单一的组件，按组件的复用程度去依次开发。像这样从全局出发，统计拆分组件的方式，好处十分明显。\n\n如今的前端开发，已不是简单的页面制作加上jQuery，就能满足要求的。前端工程师们要面对的不再是简简单单的网站，而是更为复杂的 web 应用。\n\n### 技术架构统一到 Vue 技术栈\n可以说，Vue 是为组件化而生的 View 层框架。它为应用的组件化，提供了很好的支持，还有完善的脚手架工具可用。\n团队统一技术栈有很多好处，可以降低产品间人员调动地成本、复用组件和模块代码。\n\n到目前为止，团队中的大部分产品，都完成了向 Vue 技术栈的重构迁移。\n\n### 组件化开发过程\n产品更新迭代速度，很大程度上决定了产品成败。组件化开发理念，可以快速拼装出产品，而且每个组件都可以独立的升级或替换。\n\n在产品正式开发之前，我们仔细研究设计图，统计出整个产品所包含的组件。哪些组件可复用度更高，\n就优先开发这些组件。一旦这些工作完成，就能快速拼装出产品功能页面。\n\n不难想到，前端开发的效率取决于设计稿的完整度。设计师提供的设计稿越完整，前端工程师的开发效率会越高。\n\n在智能数据市场产品（ SDMK ）的开发初期，就选择了组件化地开发方式，这很大程度上缩短了产品迭代发布周期。\n\n## 源代码管理要规范化\n\n产品团队中，几位工程师分工协作，开发不同的功能组件。各功能组件相互依赖关联，只有规范化的源代码管理流程，才能避免了因多人协作，而导致的风险和保证产品的快速持续的功能集成。\n\n### 规范化 Git 工作流\n高效的开发团队，需要规范化的代码管理流程做保证，团队直接引入了成熟的 Git 分支开发流程，并采用了每日集成的开发策略。\n\n在产品的攻坚和优化阶段，我们采用了不同的分支开发策略。\n\n在攻坚阶段，每位工程师会在自己的开发分支，完成分配到的功能组件。负责人会在每天固定的时间，将大家的代码 commit 到 daily 分支上，同时还会进行 CodeReview，做规范性检查和业务逻辑优化等等。\n\n在产品上线后，进入产品的优化阶段。这个时候大家会将分支转移到 Feature 分支，同样会进行每天的 Daily 过程。\n\n如此，大家每天的工作目标明确、成果可见，每天都很有成就感。\n\n![git workflow](http://7xocsy.com1.z0.glb.clouddn.com/blog/git-workflow.png)\n(图片来源：Git版本控制与工作流，by Sam_Lau)\n\n### 规范化 Git Commit message\n\n一次代码提交，应该尽量做到原子性，比如：完成了一次 Bugfix、完善某功能文档、对某个方法做了重构等。而每次代码提交，都应该提供格式化的 Commit message。\n\n格式化的 Commit message，有很多个好处：\n\n1. 提供更多的历史信息，方便代码 CodeReview。\n2. 可以过滤不同类型的 Commit，方便快速查找信息。\n3. 还可以由 Commit message 生成产品的 Changelog。\n\n在每天的 Daily 过程中，快速浏览 Gitlab 的提交记录中的 Commit message，可以高效的完成 Code Review。\n\n团队直接引入了广泛使用的 Angular 提交规范，比较合理和系统化，并且有现成配套的工具。\n\ncommitizen (安装 npm install -g commitizen):\n\n![commit-message](http://7xocsy.com1.z0.glb.clouddn.com/blog/commit-message.png)\n\nAngular规范：\n```\nfeat：新功能（feature）\nfix：修补bug\ndocs：文档（documentation）\nstyle： 格式（不影响代码运行的变动）\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：构建过程或辅助工具的变动\n```\n\n团队规范示例：\n![commit-demo](http://7xocsy.com1.z0.glb.clouddn.com/blog/commit-demo.png)\n\n在执行 Jenkins 构建后，还可以清楚地了解，这次构建所修改的内容：\n![jenkins-demo](http://7xocsy.com1.z0.glb.clouddn.com/blog/jenkins-demo.png)\n\n\n## 代码风格的规范化\n\n阅读规范化产品的代码，最直观感受是：所有代码，要看起来像是是出自一人之手，无论功能实现，还是代码注释。\n\n在进行规范化之前，团队需要将主要开发语言迁移到 ES6。把匕首换成宝剑，提高了攻城成功的把握。\n\n### 迁移到 ES6 和 SASS\n\n过于灵活的ES5，并不适合开发企业级 Web 应用。\n\n因为产品存在历史 ES5 代码，大家需要循序渐进的完成 ES6 的迁移，比如：\n1. 新功能代码，禁止使用 var  关键字声明变量，而是改为使用 let 或 const；\n2. 对于函数的声明，鼓励去掉 function 关键字，更多的使用箭头函数和使用函数的默认值；\n3. 用模版字符串替换掉之前的字符串拼接；\n\n像这样，逐渐深入更多的ES6特性。从实际效果看，各产品线代码迁移过程，十分地平滑自然。\n\n下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效：\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n在 CSS 方面，各产品统一为 SASS 预处理器，为 CSS 引入了许多编程语言的特性和模块化的能力。\n\n### 引入 Airbnb 的 Javascirpt 和 CSS 规范\n\n感谢 Airbnb 开源了其内部的语言规范，免去了大家设计和维护规范文档的麻烦。\n\n团队采用了，目前广泛使用和成熟的 Airbnb 语言规范，有现成的规范文档和工具可用。\n\n只有工具，才能约束大家的编码习惯。团队引入了 eslint 检查工具，再配合 Airbnb的规范，保证了大家代码的规范性。\n\n在代码编辑和“编译”阶段，eslint 插件会自动检查产品代码是否符合规范。对于不符合规范的代码，会抛出错误提示，阻止代码的执行。\n\n除了代码规范的约束，eslint 还为解释型的 Javascript 带来了部分编译特性，比如：\n\n1. 项目中声明了没有用的变量、函数和语句，eslint 会抛出错误提示；\n2. 代码中使用了具有一定风险的 for in 循环，也会给出修改建议；\n\n大家在学习 Airbnb 规范的过程中，对照 ES5 和 ES6 语法的不同，快速完成了语言的切换。\n\n对于 CSS 预处理器 SASS，我们尝试了 stylelint 工具，配合 Airbnb 开源的 CSS 规范，来规范化大家的 SASS 代码。但遗憾的是，社区开源的 CSS 规范化相关工具并不完善。编辑器 lint 插件，只找到了 atom 的版本。\n\n\n## 文档的规范化\n\n工程师们，大都不喜欢写文档。\n\n而实际情况是，文档的更新，一般都是滞后的。比如接口新增了参数，文档也需要做对应的修改，而这带来了一定的维护成本。\n\n### 源代码即文档\n组件和模块的设计拆分，应尽量符合简单的单一职责原则。这样源代码就能够做到自解释，文件名表明了文件的功能、方法名称解释了该方法的意图等等。\n\n这里，好的文件名称、方法名称就起到了文档的作用。\n\n对于接口文档，我们设计了声明式的 model 层 apischema （https://www.npmjs.com/package/apischema）。一个 model 的定义，就是一系列接口的文档。\n\n下面的代码示例中，可以直观的看出接口协议、地址和参数规则：\n\n```\n// define api\nexport const addInternalGroup = schema.post('/path/to/action', {\n  name: { type: String, required: true },\n  info: { type: String, required: true },\n});\n\n// use api\naddInternalGroup({ name: 'xxx', info: 'xxx' }).then((json) => {\n  log(json);  \n});\n```\n\n除了代码，团队中还会有很多东西要沉淀记录，必要的文档还是要有的。\n\n### 用 Markdown 写周报\n现如今，除了编程语言之外，Markdown 也早已成为了合格工程师的必备技能。大家的周报，会统一格式，用 Markdown 记录到 gitlab 之中，内容包括：工作概要、详情记录和计划等。\n\n### \b大前端周刊\n合格的工程师，每周会阅读一定量的技术文章。团队鼓励大家把每周读到的优秀内容，分享给团队小伙伴，简单记录到 Github 的 issues 之中。\n\n每周五会有一位轮岗小编，负责将 issues 中的内容，用 Markdown 编辑整理到 Github pages 中。\n\n这就成了我们的大前端周刊（https://talkingdata.github.io/fsd/）。\n\n![fsd](http://7xocsy.com1.z0.glb.clouddn.com/blog/fsd.png)\n\n## 未来展望\n\n### 从组件化到模块化\nVue的组件化能力，缩短了开发周期。但纵览多条产品线的代码，依然存在很多职责相同的代码。比如好几个产品，各自实现了一套time-format模块。\n\n我们需要将公共代码，提取到模块，不同产品分别引用这个模块就好了。感谢社区为我们提供了完善的模块化能力。\n\n产品引入的iView，为大家竖立了榜样。团队成员，都要适度参与到开源社区，每各人都是前端生态的一部分。\n\n提倡渐进式地开发方式。大家在完成功能开发后，能够多一些思考，考虑哪些代码具有通用性，将这些代码提炼出去，最后 npm publish.\n\n希望每位工程师，不止于业务，向前一步。\n\n### 从纯前端到大前端\n工程师只会浏览器端的开发技术，就很难设计出功能完整的作品，创造力也因此受到了限制。团队鼓励大家，在掌握了前端的技能后，能够突破边界，再多涉及一些 Node 开发技术、多了解一些 Http 协议的常识。\n\n工程师站在大前端的高度，就能在不同的层面考虑问题，给出最适当的解决方案。比如为了提高产品发布的可靠性，要引入灰度发布流程，团队实现了完整的灰度分流和对应的配置平台。\n\n浏览器端和 Node 端，要关注的方面不同，团队不能因此失去专注。半年来，希望团队能够从单纯的前端团队，成长为大前端团队。按照二八原则，希望能有 20% 的团队成员能够专注在 Node 方面。对于其他队员，也希望能够在仿照固有的模式，开发一些 Node 端的代码。\n\n从这一想法出发，团队启动了 Flclover（四叶草）项目，一个基于 Koa 的企业级 Node 解决方案。\n\n目前 Flclover 稳定在 0.7.x 版本，已经在内部的两个项目，完成了验证。\n\n### 从引入开源到生态共建\n\nHats off to Github.\n\n团队中引入了大量的开源模块和工具，像 NodeJS、NPM、Webpack、Vue 和 iView 等，这些开源工具让大家可以更专注在业务上面，不需要花时间去研发这些基础的东西。\n\n在我刚入行的几年，除了业务研发，还需要花费大量的时间和精力，开发工具类的东西。像公共组件、模块加载器和打包工具等，如今所有这些，都可以在社区找到完整的解决方案。\n\n团队鼓励大家都参与到开源生态的共建，形成从引入到贡献良性的开源闭环。\n\n## 最后\n半年来，团队完成了规范的推广和技术架构的统一，这些为团队规模的迅速扩大，打好了基础。接下来，团队还要普及渐进式的开发方式，完成从纯前端到大前端团队的过度。\n\n加油 2017！\n","source":"_posts/front-end-engineering-practice.md","raw":"---\ntitle: 前端工程化实践\ndate: 2017-08-18 00:00\ntags: [工程化,文档,开源,es6,git,eslint]\n---\n\n# 前端工程化实践\n\n年初有幸加入到 TalkingData，到现在半年有余。\b是时候回头看看，这半年走过的路。\n\n感谢 TD 的充分信任和赋能，使我可以在团队中大胆实践和尝试。\n\n整个团队负责很多条产品线，如果技术规范和技术栈不统一，就很难保证产品的快速迭代。在这半年里，推行组件化开发理念、规范了 Git 工作流和 Git Commit message，开发语言迁移到 ES6, 并引入了 Airbnb 规范。\n\n整个前端团队，还要经历从组件化到模块化、从引入开源到生态贡献和从纯前端到大前端团队的发展道路。\n\n## 组件化\n工程师们按设计规格，制造出机器（单页应用）的零部件（组件），就可以快速组装好一部完整的机器。\n\n同样，开发团队将设计稿拆分出一个个职责单一的组件，按组件的复用程度去依次开发。像这样从全局出发，统计拆分组件的方式，好处十分明显。\n\n如今的前端开发，已不是简单的页面制作加上jQuery，就能满足要求的。前端工程师们要面对的不再是简简单单的网站，而是更为复杂的 web 应用。\n\n### 技术架构统一到 Vue 技术栈\n可以说，Vue 是为组件化而生的 View 层框架。它为应用的组件化，提供了很好的支持，还有完善的脚手架工具可用。\n团队统一技术栈有很多好处，可以降低产品间人员调动地成本、复用组件和模块代码。\n\n到目前为止，团队中的大部分产品，都完成了向 Vue 技术栈的重构迁移。\n\n### 组件化开发过程\n产品更新迭代速度，很大程度上决定了产品成败。组件化开发理念，可以快速拼装出产品，而且每个组件都可以独立的升级或替换。\n\n在产品正式开发之前，我们仔细研究设计图，统计出整个产品所包含的组件。哪些组件可复用度更高，\n就优先开发这些组件。一旦这些工作完成，就能快速拼装出产品功能页面。\n\n不难想到，前端开发的效率取决于设计稿的完整度。设计师提供的设计稿越完整，前端工程师的开发效率会越高。\n\n在智能数据市场产品（ SDMK ）的开发初期，就选择了组件化地开发方式，这很大程度上缩短了产品迭代发布周期。\n\n## 源代码管理要规范化\n\n产品团队中，几位工程师分工协作，开发不同的功能组件。各功能组件相互依赖关联，只有规范化的源代码管理流程，才能避免了因多人协作，而导致的风险和保证产品的快速持续的功能集成。\n\n### 规范化 Git 工作流\n高效的开发团队，需要规范化的代码管理流程做保证，团队直接引入了成熟的 Git 分支开发流程，并采用了每日集成的开发策略。\n\n在产品的攻坚和优化阶段，我们采用了不同的分支开发策略。\n\n在攻坚阶段，每位工程师会在自己的开发分支，完成分配到的功能组件。负责人会在每天固定的时间，将大家的代码 commit 到 daily 分支上，同时还会进行 CodeReview，做规范性检查和业务逻辑优化等等。\n\n在产品上线后，进入产品的优化阶段。这个时候大家会将分支转移到 Feature 分支，同样会进行每天的 Daily 过程。\n\n如此，大家每天的工作目标明确、成果可见，每天都很有成就感。\n\n![git workflow](http://7xocsy.com1.z0.glb.clouddn.com/blog/git-workflow.png)\n(图片来源：Git版本控制与工作流，by Sam_Lau)\n\n### 规范化 Git Commit message\n\n一次代码提交，应该尽量做到原子性，比如：完成了一次 Bugfix、完善某功能文档、对某个方法做了重构等。而每次代码提交，都应该提供格式化的 Commit message。\n\n格式化的 Commit message，有很多个好处：\n\n1. 提供更多的历史信息，方便代码 CodeReview。\n2. 可以过滤不同类型的 Commit，方便快速查找信息。\n3. 还可以由 Commit message 生成产品的 Changelog。\n\n在每天的 Daily 过程中，快速浏览 Gitlab 的提交记录中的 Commit message，可以高效的完成 Code Review。\n\n团队直接引入了广泛使用的 Angular 提交规范，比较合理和系统化，并且有现成配套的工具。\n\ncommitizen (安装 npm install -g commitizen):\n\n![commit-message](http://7xocsy.com1.z0.glb.clouddn.com/blog/commit-message.png)\n\nAngular规范：\n```\nfeat：新功能（feature）\nfix：修补bug\ndocs：文档（documentation）\nstyle： 格式（不影响代码运行的变动）\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：构建过程或辅助工具的变动\n```\n\n团队规范示例：\n![commit-demo](http://7xocsy.com1.z0.glb.clouddn.com/blog/commit-demo.png)\n\n在执行 Jenkins 构建后，还可以清楚地了解，这次构建所修改的内容：\n![jenkins-demo](http://7xocsy.com1.z0.glb.clouddn.com/blog/jenkins-demo.png)\n\n\n## 代码风格的规范化\n\n阅读规范化产品的代码，最直观感受是：所有代码，要看起来像是是出自一人之手，无论功能实现，还是代码注释。\n\n在进行规范化之前，团队需要将主要开发语言迁移到 ES6。把匕首换成宝剑，提高了攻城成功的把握。\n\n### 迁移到 ES6 和 SASS\n\n过于灵活的ES5，并不适合开发企业级 Web 应用。\n\n因为产品存在历史 ES5 代码，大家需要循序渐进的完成 ES6 的迁移，比如：\n1. 新功能代码，禁止使用 var  关键字声明变量，而是改为使用 let 或 const；\n2. 对于函数的声明，鼓励去掉 function 关键字，更多的使用箭头函数和使用函数的默认值；\n3. 用模版字符串替换掉之前的字符串拼接；\n\n像这样，逐渐深入更多的ES6特性。从实际效果看，各产品线代码迁移过程，十分地平滑自然。\n\n下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效：\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n在 CSS 方面，各产品统一为 SASS 预处理器，为 CSS 引入了许多编程语言的特性和模块化的能力。\n\n### 引入 Airbnb 的 Javascirpt 和 CSS 规范\n\n感谢 Airbnb 开源了其内部的语言规范，免去了大家设计和维护规范文档的麻烦。\n\n团队采用了，目前广泛使用和成熟的 Airbnb 语言规范，有现成的规范文档和工具可用。\n\n只有工具，才能约束大家的编码习惯。团队引入了 eslint 检查工具，再配合 Airbnb的规范，保证了大家代码的规范性。\n\n在代码编辑和“编译”阶段，eslint 插件会自动检查产品代码是否符合规范。对于不符合规范的代码，会抛出错误提示，阻止代码的执行。\n\n除了代码规范的约束，eslint 还为解释型的 Javascript 带来了部分编译特性，比如：\n\n1. 项目中声明了没有用的变量、函数和语句，eslint 会抛出错误提示；\n2. 代码中使用了具有一定风险的 for in 循环，也会给出修改建议；\n\n大家在学习 Airbnb 规范的过程中，对照 ES5 和 ES6 语法的不同，快速完成了语言的切换。\n\n对于 CSS 预处理器 SASS，我们尝试了 stylelint 工具，配合 Airbnb 开源的 CSS 规范，来规范化大家的 SASS 代码。但遗憾的是，社区开源的 CSS 规范化相关工具并不完善。编辑器 lint 插件，只找到了 atom 的版本。\n\n\n## 文档的规范化\n\n工程师们，大都不喜欢写文档。\n\n而实际情况是，文档的更新，一般都是滞后的。比如接口新增了参数，文档也需要做对应的修改，而这带来了一定的维护成本。\n\n### 源代码即文档\n组件和模块的设计拆分，应尽量符合简单的单一职责原则。这样源代码就能够做到自解释，文件名表明了文件的功能、方法名称解释了该方法的意图等等。\n\n这里，好的文件名称、方法名称就起到了文档的作用。\n\n对于接口文档，我们设计了声明式的 model 层 apischema （https://www.npmjs.com/package/apischema）。一个 model 的定义，就是一系列接口的文档。\n\n下面的代码示例中，可以直观的看出接口协议、地址和参数规则：\n\n```\n// define api\nexport const addInternalGroup = schema.post('/path/to/action', {\n  name: { type: String, required: true },\n  info: { type: String, required: true },\n});\n\n// use api\naddInternalGroup({ name: 'xxx', info: 'xxx' }).then((json) => {\n  log(json);  \n});\n```\n\n除了代码，团队中还会有很多东西要沉淀记录，必要的文档还是要有的。\n\n### 用 Markdown 写周报\n现如今，除了编程语言之外，Markdown 也早已成为了合格工程师的必备技能。大家的周报，会统一格式，用 Markdown 记录到 gitlab 之中，内容包括：工作概要、详情记录和计划等。\n\n### \b大前端周刊\n合格的工程师，每周会阅读一定量的技术文章。团队鼓励大家把每周读到的优秀内容，分享给团队小伙伴，简单记录到 Github 的 issues 之中。\n\n每周五会有一位轮岗小编，负责将 issues 中的内容，用 Markdown 编辑整理到 Github pages 中。\n\n这就成了我们的大前端周刊（https://talkingdata.github.io/fsd/）。\n\n![fsd](http://7xocsy.com1.z0.glb.clouddn.com/blog/fsd.png)\n\n## 未来展望\n\n### 从组件化到模块化\nVue的组件化能力，缩短了开发周期。但纵览多条产品线的代码，依然存在很多职责相同的代码。比如好几个产品，各自实现了一套time-format模块。\n\n我们需要将公共代码，提取到模块，不同产品分别引用这个模块就好了。感谢社区为我们提供了完善的模块化能力。\n\n产品引入的iView，为大家竖立了榜样。团队成员，都要适度参与到开源社区，每各人都是前端生态的一部分。\n\n提倡渐进式地开发方式。大家在完成功能开发后，能够多一些思考，考虑哪些代码具有通用性，将这些代码提炼出去，最后 npm publish.\n\n希望每位工程师，不止于业务，向前一步。\n\n### 从纯前端到大前端\n工程师只会浏览器端的开发技术，就很难设计出功能完整的作品，创造力也因此受到了限制。团队鼓励大家，在掌握了前端的技能后，能够突破边界，再多涉及一些 Node 开发技术、多了解一些 Http 协议的常识。\n\n工程师站在大前端的高度，就能在不同的层面考虑问题，给出最适当的解决方案。比如为了提高产品发布的可靠性，要引入灰度发布流程，团队实现了完整的灰度分流和对应的配置平台。\n\n浏览器端和 Node 端，要关注的方面不同，团队不能因此失去专注。半年来，希望团队能够从单纯的前端团队，成长为大前端团队。按照二八原则，希望能有 20% 的团队成员能够专注在 Node 方面。对于其他队员，也希望能够在仿照固有的模式，开发一些 Node 端的代码。\n\n从这一想法出发，团队启动了 Flclover（四叶草）项目，一个基于 Koa 的企业级 Node 解决方案。\n\n目前 Flclover 稳定在 0.7.x 版本，已经在内部的两个项目，完成了验证。\n\n### 从引入开源到生态共建\n\nHats off to Github.\n\n团队中引入了大量的开源模块和工具，像 NodeJS、NPM、Webpack、Vue 和 iView 等，这些开源工具让大家可以更专注在业务上面，不需要花时间去研发这些基础的东西。\n\n在我刚入行的几年，除了业务研发，还需要花费大量的时间和精力，开发工具类的东西。像公共组件、模块加载器和打包工具等，如今所有这些，都可以在社区找到完整的解决方案。\n\n团队鼓励大家都参与到开源生态的共建，形成从引入到贡献良性的开源闭环。\n\n## 最后\n半年来，团队完成了规范的推广和技术架构的统一，这些为团队规模的迅速扩大，打好了基础。接下来，团队还要普及渐进式的开发方式，完成从纯前端到大前端团队的过度。\n\n加油 2017！\n","slug":"front-end-engineering-practice","published":1,"updated":"2017-08-20T15:53:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kwxrl40000u1jip5dficj5","content":"<h1 id=\"前端工程化实践\"><a href=\"#前端工程化实践\" class=\"headerlink\" title=\"前端工程化实践\"></a>前端工程化实践</h1><p>年初有幸加入到 TalkingData，到现在半年有余。\b是时候回头看看，这半年走过的路。</p>\n<p>感谢 TD 的充分信任和赋能，使我可以在团队中大胆实践和尝试。</p>\n<p>整个团队负责很多条产品线，如果技术规范和技术栈不统一，就很难保证产品的快速迭代。在这半年里，推行组件化开发理念、规范了 Git 工作流和 Git Commit message，开发语言迁移到 ES6, 并引入了 Airbnb 规范。</p>\n<p>整个前端团队，还要经历从组件化到模块化、从引入开源到生态贡献和从纯前端到大前端团队的发展道路。</p>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><p>工程师们按设计规格，制造出机器（单页应用）的零部件（组件），就可以快速组装好一部完整的机器。</p>\n<p>同样，开发团队将设计稿拆分出一个个职责单一的组件，按组件的复用程度去依次开发。像这样从全局出发，统计拆分组件的方式，好处十分明显。</p>\n<p>如今的前端开发，已不是简单的页面制作加上jQuery，就能满足要求的。前端工程师们要面对的不再是简简单单的网站，而是更为复杂的 web 应用。</p>\n<h3 id=\"技术架构统一到-Vue-技术栈\"><a href=\"#技术架构统一到-Vue-技术栈\" class=\"headerlink\" title=\"技术架构统一到 Vue 技术栈\"></a>技术架构统一到 Vue 技术栈</h3><p>可以说，Vue 是为组件化而生的 View 层框架。它为应用的组件化，提供了很好的支持，还有完善的脚手架工具可用。<br>团队统一技术栈有很多好处，可以降低产品间人员调动地成本、复用组件和模块代码。</p>\n<p>到目前为止，团队中的大部分产品，都完成了向 Vue 技术栈的重构迁移。</p>\n<h3 id=\"组件化开发过程\"><a href=\"#组件化开发过程\" class=\"headerlink\" title=\"组件化开发过程\"></a>组件化开发过程</h3><p>产品更新迭代速度，很大程度上决定了产品成败。组件化开发理念，可以快速拼装出产品，而且每个组件都可以独立的升级或替换。</p>\n<p>在产品正式开发之前，我们仔细研究设计图，统计出整个产品所包含的组件。哪些组件可复用度更高，<br>就优先开发这些组件。一旦这些工作完成，就能快速拼装出产品功能页面。</p>\n<p>不难想到，前端开发的效率取决于设计稿的完整度。设计师提供的设计稿越完整，前端工程师的开发效率会越高。</p>\n<p>在智能数据市场产品（ SDMK ）的开发初期，就选择了组件化地开发方式，这很大程度上缩短了产品迭代发布周期。</p>\n<h2 id=\"源代码管理要规范化\"><a href=\"#源代码管理要规范化\" class=\"headerlink\" title=\"源代码管理要规范化\"></a>源代码管理要规范化</h2><p>产品团队中，几位工程师分工协作，开发不同的功能组件。各功能组件相互依赖关联，只有规范化的源代码管理流程，才能避免了因多人协作，而导致的风险和保证产品的快速持续的功能集成。</p>\n<h3 id=\"规范化-Git-工作流\"><a href=\"#规范化-Git-工作流\" class=\"headerlink\" title=\"规范化 Git 工作流\"></a>规范化 Git 工作流</h3><p>高效的开发团队，需要规范化的代码管理流程做保证，团队直接引入了成熟的 Git 分支开发流程，并采用了每日集成的开发策略。</p>\n<p>在产品的攻坚和优化阶段，我们采用了不同的分支开发策略。</p>\n<p>在攻坚阶段，每位工程师会在自己的开发分支，完成分配到的功能组件。负责人会在每天固定的时间，将大家的代码 commit 到 daily 分支上，同时还会进行 CodeReview，做规范性检查和业务逻辑优化等等。</p>\n<p>在产品上线后，进入产品的优化阶段。这个时候大家会将分支转移到 Feature 分支，同样会进行每天的 Daily 过程。</p>\n<p>如此，大家每天的工作目标明确、成果可见，每天都很有成就感。</p>\n<p><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/git-workflow.png\" alt=\"git workflow\"><br>(图片来源：Git版本控制与工作流，by Sam_Lau)</p>\n<h3 id=\"规范化-Git-Commit-message\"><a href=\"#规范化-Git-Commit-message\" class=\"headerlink\" title=\"规范化 Git Commit message\"></a>规范化 Git Commit message</h3><p>一次代码提交，应该尽量做到原子性，比如：完成了一次 Bugfix、完善某功能文档、对某个方法做了重构等。而每次代码提交，都应该提供格式化的 Commit message。</p>\n<p>格式化的 Commit message，有很多个好处：</p>\n<ol>\n<li>提供更多的历史信息，方便代码 CodeReview。</li>\n<li>可以过滤不同类型的 Commit，方便快速查找信息。</li>\n<li>还可以由 Commit message 生成产品的 Changelog。</li>\n</ol>\n<p>在每天的 Daily 过程中，快速浏览 Gitlab 的提交记录中的 Commit message，可以高效的完成 Code Review。</p>\n<p>团队直接引入了广泛使用的 Angular 提交规范，比较合理和系统化，并且有现成配套的工具。</p>\n<p>commitizen (安装 npm install -g commitizen):</p>\n<p><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/commit-message.png\" alt=\"commit-message\"></p>\n<p>Angular规范：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">feat：新功能（feature）</div><div class=\"line\">fix：修补bug</div><div class=\"line\">docs：文档（documentation）</div><div class=\"line\">style： 格式（不影响代码运行的变动）</div><div class=\"line\">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</div><div class=\"line\">test：增加测试</div><div class=\"line\">chore：构建过程或辅助工具的变动</div></pre></td></tr></table></figure></p>\n<p>团队规范示例：<br><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/commit-demo.png\" alt=\"commit-demo\"></p>\n<p>在执行 Jenkins 构建后，还可以清楚地了解，这次构建所修改的内容：<br><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/jenkins-demo.png\" alt=\"jenkins-demo\"></p>\n<h2 id=\"代码风格的规范化\"><a href=\"#代码风格的规范化\" class=\"headerlink\" title=\"代码风格的规范化\"></a>代码风格的规范化</h2><p>阅读规范化产品的代码，最直观感受是：所有代码，要看起来像是是出自一人之手，无论功能实现，还是代码注释。</p>\n<p>在进行规范化之前，团队需要将主要开发语言迁移到 ES6。把匕首换成宝剑，提高了攻城成功的把握。</p>\n<h3 id=\"迁移到-ES6-和-SASS\"><a href=\"#迁移到-ES6-和-SASS\" class=\"headerlink\" title=\"迁移到 ES6 和 SASS\"></a>迁移到 ES6 和 SASS</h3><p>过于灵活的ES5，并不适合开发企业级 Web 应用。</p>\n<p>因为产品存在历史 ES5 代码，大家需要循序渐进的完成 ES6 的迁移，比如：</p>\n<ol>\n<li>新功能代码，禁止使用 var  关键字声明变量，而是改为使用 let 或 const；</li>\n<li>对于函数的声明，鼓励去掉 function 关键字，更多的使用箭头函数和使用函数的默认值；</li>\n<li>用模版字符串替换掉之前的字符串拼接；</li>\n</ol>\n<p>像这样，逐渐深入更多的ES6特性。从实际效果看，各产品线代码迁移过程，十分地平滑自然。</p>\n<p>下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\"><span class=\"keyword\">const</span> len = items.length;</div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [];</div><div class=\"line\"><span class=\"keyword\">let</span> i;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">  itemsCopy[i] = items[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>\n<p>在 CSS 方面，各产品统一为 SASS 预处理器，为 CSS 引入了许多编程语言的特性和模块化的能力。</p>\n<h3 id=\"引入-Airbnb-的-Javascirpt-和-CSS-规范\"><a href=\"#引入-Airbnb-的-Javascirpt-和-CSS-规范\" class=\"headerlink\" title=\"引入 Airbnb 的 Javascirpt 和 CSS 规范\"></a>引入 Airbnb 的 Javascirpt 和 CSS 规范</h3><p>感谢 Airbnb 开源了其内部的语言规范，免去了大家设计和维护规范文档的麻烦。</p>\n<p>团队采用了，目前广泛使用和成熟的 Airbnb 语言规范，有现成的规范文档和工具可用。</p>\n<p>只有工具，才能约束大家的编码习惯。团队引入了 eslint 检查工具，再配合 Airbnb的规范，保证了大家代码的规范性。</p>\n<p>在代码编辑和“编译”阶段，eslint 插件会自动检查产品代码是否符合规范。对于不符合规范的代码，会抛出错误提示，阻止代码的执行。</p>\n<p>除了代码规范的约束，eslint 还为解释型的 Javascript 带来了部分编译特性，比如：</p>\n<ol>\n<li>项目中声明了没有用的变量、函数和语句，eslint 会抛出错误提示；</li>\n<li>代码中使用了具有一定风险的 for in 循环，也会给出修改建议；</li>\n</ol>\n<p>大家在学习 Airbnb 规范的过程中，对照 ES5 和 ES6 语法的不同，快速完成了语言的切换。</p>\n<p>对于 CSS 预处理器 SASS，我们尝试了 stylelint 工具，配合 Airbnb 开源的 CSS 规范，来规范化大家的 SASS 代码。但遗憾的是，社区开源的 CSS 规范化相关工具并不完善。编辑器 lint 插件，只找到了 atom 的版本。</p>\n<h2 id=\"文档的规范化\"><a href=\"#文档的规范化\" class=\"headerlink\" title=\"文档的规范化\"></a>文档的规范化</h2><p>工程师们，大都不喜欢写文档。</p>\n<p>而实际情况是，文档的更新，一般都是滞后的。比如接口新增了参数，文档也需要做对应的修改，而这带来了一定的维护成本。</p>\n<h3 id=\"源代码即文档\"><a href=\"#源代码即文档\" class=\"headerlink\" title=\"源代码即文档\"></a>源代码即文档</h3><p>组件和模块的设计拆分，应尽量符合简单的单一职责原则。这样源代码就能够做到自解释，文件名表明了文件的功能、方法名称解释了该方法的意图等等。</p>\n<p>这里，好的文件名称、方法名称就起到了文档的作用。</p>\n<p>对于接口文档，我们设计了声明式的 model 层 apischema （<a href=\"https://www.npmjs.com/package/apischema）。一个\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/apischema）。一个</a> model 的定义，就是一系列接口的文档。</p>\n<p>下面的代码示例中，可以直观的看出接口协议、地址和参数规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// define api</div><div class=\"line\">export const addInternalGroup = schema.post(&apos;/path/to/action&apos;, &#123;</div><div class=\"line\">  name: &#123; type: String, required: true &#125;,</div><div class=\"line\">  info: &#123; type: String, required: true &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// use api</div><div class=\"line\">addInternalGroup(&#123; name: &apos;xxx&apos;, info: &apos;xxx&apos; &#125;).then((json) =&gt; &#123;</div><div class=\"line\">  log(json);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>除了代码，团队中还会有很多东西要沉淀记录，必要的文档还是要有的。</p>\n<h3 id=\"用-Markdown-写周报\"><a href=\"#用-Markdown-写周报\" class=\"headerlink\" title=\"用 Markdown 写周报\"></a>用 Markdown 写周报</h3><p>现如今，除了编程语言之外，Markdown 也早已成为了合格工程师的必备技能。大家的周报，会统一格式，用 Markdown 记录到 gitlab 之中，内容包括：工作概要、详情记录和计划等。</p>\n<h3 id=\"大前端周刊\"><a href=\"#大前端周刊\" class=\"headerlink\" title=\"\b大前端周刊\"></a>\b大前端周刊</h3><p>合格的工程师，每周会阅读一定量的技术文章。团队鼓励大家把每周读到的优秀内容，分享给团队小伙伴，简单记录到 Github 的 issues 之中。</p>\n<p>每周五会有一位轮岗小编，负责将 issues 中的内容，用 Markdown 编辑整理到 Github pages 中。</p>\n<p>这就成了我们的大前端周刊（<a href=\"https://talkingdata.github.io/fsd/）。\" target=\"_blank\" rel=\"external\">https://talkingdata.github.io/fsd/）。</a></p>\n<p><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/fsd.png\" alt=\"fsd\"></p>\n<h2 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h2><h3 id=\"从组件化到模块化\"><a href=\"#从组件化到模块化\" class=\"headerlink\" title=\"从组件化到模块化\"></a>从组件化到模块化</h3><p>Vue的组件化能力，缩短了开发周期。但纵览多条产品线的代码，依然存在很多职责相同的代码。比如好几个产品，各自实现了一套time-format模块。</p>\n<p>我们需要将公共代码，提取到模块，不同产品分别引用这个模块就好了。感谢社区为我们提供了完善的模块化能力。</p>\n<p>产品引入的iView，为大家竖立了榜样。团队成员，都要适度参与到开源社区，每各人都是前端生态的一部分。</p>\n<p>提倡渐进式地开发方式。大家在完成功能开发后，能够多一些思考，考虑哪些代码具有通用性，将这些代码提炼出去，最后 npm publish.</p>\n<p>希望每位工程师，不止于业务，向前一步。</p>\n<h3 id=\"从纯前端到大前端\"><a href=\"#从纯前端到大前端\" class=\"headerlink\" title=\"从纯前端到大前端\"></a>从纯前端到大前端</h3><p>工程师只会浏览器端的开发技术，就很难设计出功能完整的作品，创造力也因此受到了限制。团队鼓励大家，在掌握了前端的技能后，能够突破边界，再多涉及一些 Node 开发技术、多了解一些 Http 协议的常识。</p>\n<p>工程师站在大前端的高度，就能在不同的层面考虑问题，给出最适当的解决方案。比如为了提高产品发布的可靠性，要引入灰度发布流程，团队实现了完整的灰度分流和对应的配置平台。</p>\n<p>浏览器端和 Node 端，要关注的方面不同，团队不能因此失去专注。半年来，希望团队能够从单纯的前端团队，成长为大前端团队。按照二八原则，希望能有 20% 的团队成员能够专注在 Node 方面。对于其他队员，也希望能够在仿照固有的模式，开发一些 Node 端的代码。</p>\n<p>从这一想法出发，团队启动了 Flclover（四叶草）项目，一个基于 Koa 的企业级 Node 解决方案。</p>\n<p>目前 Flclover 稳定在 0.7.x 版本，已经在内部的两个项目，完成了验证。</p>\n<h3 id=\"从引入开源到生态共建\"><a href=\"#从引入开源到生态共建\" class=\"headerlink\" title=\"从引入开源到生态共建\"></a>从引入开源到生态共建</h3><p>Hats off to Github.</p>\n<p>团队中引入了大量的开源模块和工具，像 NodeJS、NPM、Webpack、Vue 和 iView 等，这些开源工具让大家可以更专注在业务上面，不需要花时间去研发这些基础的东西。</p>\n<p>在我刚入行的几年，除了业务研发，还需要花费大量的时间和精力，开发工具类的东西。像公共组件、模块加载器和打包工具等，如今所有这些，都可以在社区找到完整的解决方案。</p>\n<p>团队鼓励大家都参与到开源生态的共建，形成从引入到贡献良性的开源闭环。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>半年来，团队完成了规范的推广和技术架构的统一，这些为团队规模的迅速扩大，打好了基础。接下来，团队还要普及渐进式的开发方式，完成从纯前端到大前端团队的过度。</p>\n<p>加油 2017！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端工程化实践\"><a href=\"#前端工程化实践\" class=\"headerlink\" title=\"前端工程化实践\"></a>前端工程化实践</h1><p>年初有幸加入到 TalkingData，到现在半年有余。\b是时候回头看看，这半年走过的路。</p>\n<p>感谢 TD 的充分信任和赋能，使我可以在团队中大胆实践和尝试。</p>\n<p>整个团队负责很多条产品线，如果技术规范和技术栈不统一，就很难保证产品的快速迭代。在这半年里，推行组件化开发理念、规范了 Git 工作流和 Git Commit message，开发语言迁移到 ES6, 并引入了 Airbnb 规范。</p>\n<p>整个前端团队，还要经历从组件化到模块化、从引入开源到生态贡献和从纯前端到大前端团队的发展道路。</p>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><p>工程师们按设计规格，制造出机器（单页应用）的零部件（组件），就可以快速组装好一部完整的机器。</p>\n<p>同样，开发团队将设计稿拆分出一个个职责单一的组件，按组件的复用程度去依次开发。像这样从全局出发，统计拆分组件的方式，好处十分明显。</p>\n<p>如今的前端开发，已不是简单的页面制作加上jQuery，就能满足要求的。前端工程师们要面对的不再是简简单单的网站，而是更为复杂的 web 应用。</p>\n<h3 id=\"技术架构统一到-Vue-技术栈\"><a href=\"#技术架构统一到-Vue-技术栈\" class=\"headerlink\" title=\"技术架构统一到 Vue 技术栈\"></a>技术架构统一到 Vue 技术栈</h3><p>可以说，Vue 是为组件化而生的 View 层框架。它为应用的组件化，提供了很好的支持，还有完善的脚手架工具可用。<br>团队统一技术栈有很多好处，可以降低产品间人员调动地成本、复用组件和模块代码。</p>\n<p>到目前为止，团队中的大部分产品，都完成了向 Vue 技术栈的重构迁移。</p>\n<h3 id=\"组件化开发过程\"><a href=\"#组件化开发过程\" class=\"headerlink\" title=\"组件化开发过程\"></a>组件化开发过程</h3><p>产品更新迭代速度，很大程度上决定了产品成败。组件化开发理念，可以快速拼装出产品，而且每个组件都可以独立的升级或替换。</p>\n<p>在产品正式开发之前，我们仔细研究设计图，统计出整个产品所包含的组件。哪些组件可复用度更高，<br>就优先开发这些组件。一旦这些工作完成，就能快速拼装出产品功能页面。</p>\n<p>不难想到，前端开发的效率取决于设计稿的完整度。设计师提供的设计稿越完整，前端工程师的开发效率会越高。</p>\n<p>在智能数据市场产品（ SDMK ）的开发初期，就选择了组件化地开发方式，这很大程度上缩短了产品迭代发布周期。</p>\n<h2 id=\"源代码管理要规范化\"><a href=\"#源代码管理要规范化\" class=\"headerlink\" title=\"源代码管理要规范化\"></a>源代码管理要规范化</h2><p>产品团队中，几位工程师分工协作，开发不同的功能组件。各功能组件相互依赖关联，只有规范化的源代码管理流程，才能避免了因多人协作，而导致的风险和保证产品的快速持续的功能集成。</p>\n<h3 id=\"规范化-Git-工作流\"><a href=\"#规范化-Git-工作流\" class=\"headerlink\" title=\"规范化 Git 工作流\"></a>规范化 Git 工作流</h3><p>高效的开发团队，需要规范化的代码管理流程做保证，团队直接引入了成熟的 Git 分支开发流程，并采用了每日集成的开发策略。</p>\n<p>在产品的攻坚和优化阶段，我们采用了不同的分支开发策略。</p>\n<p>在攻坚阶段，每位工程师会在自己的开发分支，完成分配到的功能组件。负责人会在每天固定的时间，将大家的代码 commit 到 daily 分支上，同时还会进行 CodeReview，做规范性检查和业务逻辑优化等等。</p>\n<p>在产品上线后，进入产品的优化阶段。这个时候大家会将分支转移到 Feature 分支，同样会进行每天的 Daily 过程。</p>\n<p>如此，大家每天的工作目标明确、成果可见，每天都很有成就感。</p>\n<p><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/git-workflow.png\" alt=\"git workflow\"><br>(图片来源：Git版本控制与工作流，by Sam_Lau)</p>\n<h3 id=\"规范化-Git-Commit-message\"><a href=\"#规范化-Git-Commit-message\" class=\"headerlink\" title=\"规范化 Git Commit message\"></a>规范化 Git Commit message</h3><p>一次代码提交，应该尽量做到原子性，比如：完成了一次 Bugfix、完善某功能文档、对某个方法做了重构等。而每次代码提交，都应该提供格式化的 Commit message。</p>\n<p>格式化的 Commit message，有很多个好处：</p>\n<ol>\n<li>提供更多的历史信息，方便代码 CodeReview。</li>\n<li>可以过滤不同类型的 Commit，方便快速查找信息。</li>\n<li>还可以由 Commit message 生成产品的 Changelog。</li>\n</ol>\n<p>在每天的 Daily 过程中，快速浏览 Gitlab 的提交记录中的 Commit message，可以高效的完成 Code Review。</p>\n<p>团队直接引入了广泛使用的 Angular 提交规范，比较合理和系统化，并且有现成配套的工具。</p>\n<p>commitizen (安装 npm install -g commitizen):</p>\n<p><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/commit-message.png\" alt=\"commit-message\"></p>\n<p>Angular规范：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">feat：新功能（feature）</div><div class=\"line\">fix：修补bug</div><div class=\"line\">docs：文档（documentation）</div><div class=\"line\">style： 格式（不影响代码运行的变动）</div><div class=\"line\">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</div><div class=\"line\">test：增加测试</div><div class=\"line\">chore：构建过程或辅助工具的变动</div></pre></td></tr></table></figure></p>\n<p>团队规范示例：<br><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/commit-demo.png\" alt=\"commit-demo\"></p>\n<p>在执行 Jenkins 构建后，还可以清楚地了解，这次构建所修改的内容：<br><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/jenkins-demo.png\" alt=\"jenkins-demo\"></p>\n<h2 id=\"代码风格的规范化\"><a href=\"#代码风格的规范化\" class=\"headerlink\" title=\"代码风格的规范化\"></a>代码风格的规范化</h2><p>阅读规范化产品的代码，最直观感受是：所有代码，要看起来像是是出自一人之手，无论功能实现，还是代码注释。</p>\n<p>在进行规范化之前，团队需要将主要开发语言迁移到 ES6。把匕首换成宝剑，提高了攻城成功的把握。</p>\n<h3 id=\"迁移到-ES6-和-SASS\"><a href=\"#迁移到-ES6-和-SASS\" class=\"headerlink\" title=\"迁移到 ES6 和 SASS\"></a>迁移到 ES6 和 SASS</h3><p>过于灵活的ES5，并不适合开发企业级 Web 应用。</p>\n<p>因为产品存在历史 ES5 代码，大家需要循序渐进的完成 ES6 的迁移，比如：</p>\n<ol>\n<li>新功能代码，禁止使用 var  关键字声明变量，而是改为使用 let 或 const；</li>\n<li>对于函数的声明，鼓励去掉 function 关键字，更多的使用箭头函数和使用函数的默认值；</li>\n<li>用模版字符串替换掉之前的字符串拼接；</li>\n</ol>\n<p>像这样，逐渐深入更多的ES6特性。从实际效果看，各产品线代码迁移过程，十分地平滑自然。</p>\n<p>下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\"><span class=\"keyword\">const</span> len = items.length;</div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [];</div><div class=\"line\"><span class=\"keyword\">let</span> i;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">  itemsCopy[i] = items[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>\n<p>在 CSS 方面，各产品统一为 SASS 预处理器，为 CSS 引入了许多编程语言的特性和模块化的能力。</p>\n<h3 id=\"引入-Airbnb-的-Javascirpt-和-CSS-规范\"><a href=\"#引入-Airbnb-的-Javascirpt-和-CSS-规范\" class=\"headerlink\" title=\"引入 Airbnb 的 Javascirpt 和 CSS 规范\"></a>引入 Airbnb 的 Javascirpt 和 CSS 规范</h3><p>感谢 Airbnb 开源了其内部的语言规范，免去了大家设计和维护规范文档的麻烦。</p>\n<p>团队采用了，目前广泛使用和成熟的 Airbnb 语言规范，有现成的规范文档和工具可用。</p>\n<p>只有工具，才能约束大家的编码习惯。团队引入了 eslint 检查工具，再配合 Airbnb的规范，保证了大家代码的规范性。</p>\n<p>在代码编辑和“编译”阶段，eslint 插件会自动检查产品代码是否符合规范。对于不符合规范的代码，会抛出错误提示，阻止代码的执行。</p>\n<p>除了代码规范的约束，eslint 还为解释型的 Javascript 带来了部分编译特性，比如：</p>\n<ol>\n<li>项目中声明了没有用的变量、函数和语句，eslint 会抛出错误提示；</li>\n<li>代码中使用了具有一定风险的 for in 循环，也会给出修改建议；</li>\n</ol>\n<p>大家在学习 Airbnb 规范的过程中，对照 ES5 和 ES6 语法的不同，快速完成了语言的切换。</p>\n<p>对于 CSS 预处理器 SASS，我们尝试了 stylelint 工具，配合 Airbnb 开源的 CSS 规范，来规范化大家的 SASS 代码。但遗憾的是，社区开源的 CSS 规范化相关工具并不完善。编辑器 lint 插件，只找到了 atom 的版本。</p>\n<h2 id=\"文档的规范化\"><a href=\"#文档的规范化\" class=\"headerlink\" title=\"文档的规范化\"></a>文档的规范化</h2><p>工程师们，大都不喜欢写文档。</p>\n<p>而实际情况是，文档的更新，一般都是滞后的。比如接口新增了参数，文档也需要做对应的修改，而这带来了一定的维护成本。</p>\n<h3 id=\"源代码即文档\"><a href=\"#源代码即文档\" class=\"headerlink\" title=\"源代码即文档\"></a>源代码即文档</h3><p>组件和模块的设计拆分，应尽量符合简单的单一职责原则。这样源代码就能够做到自解释，文件名表明了文件的功能、方法名称解释了该方法的意图等等。</p>\n<p>这里，好的文件名称、方法名称就起到了文档的作用。</p>\n<p>对于接口文档，我们设计了声明式的 model 层 apischema （<a href=\"https://www.npmjs.com/package/apischema）。一个\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/apischema）。一个</a> model 的定义，就是一系列接口的文档。</p>\n<p>下面的代码示例中，可以直观的看出接口协议、地址和参数规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// define api</div><div class=\"line\">export const addInternalGroup = schema.post(&apos;/path/to/action&apos;, &#123;</div><div class=\"line\">  name: &#123; type: String, required: true &#125;,</div><div class=\"line\">  info: &#123; type: String, required: true &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// use api</div><div class=\"line\">addInternalGroup(&#123; name: &apos;xxx&apos;, info: &apos;xxx&apos; &#125;).then((json) =&gt; &#123;</div><div class=\"line\">  log(json);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>除了代码，团队中还会有很多东西要沉淀记录，必要的文档还是要有的。</p>\n<h3 id=\"用-Markdown-写周报\"><a href=\"#用-Markdown-写周报\" class=\"headerlink\" title=\"用 Markdown 写周报\"></a>用 Markdown 写周报</h3><p>现如今，除了编程语言之外，Markdown 也早已成为了合格工程师的必备技能。大家的周报，会统一格式，用 Markdown 记录到 gitlab 之中，内容包括：工作概要、详情记录和计划等。</p>\n<h3 id=\"大前端周刊\"><a href=\"#大前端周刊\" class=\"headerlink\" title=\"\b大前端周刊\"></a>\b大前端周刊</h3><p>合格的工程师，每周会阅读一定量的技术文章。团队鼓励大家把每周读到的优秀内容，分享给团队小伙伴，简单记录到 Github 的 issues 之中。</p>\n<p>每周五会有一位轮岗小编，负责将 issues 中的内容，用 Markdown 编辑整理到 Github pages 中。</p>\n<p>这就成了我们的大前端周刊（<a href=\"https://talkingdata.github.io/fsd/）。\" target=\"_blank\" rel=\"external\">https://talkingdata.github.io/fsd/）。</a></p>\n<p><img src=\"http://7xocsy.com1.z0.glb.clouddn.com/blog/fsd.png\" alt=\"fsd\"></p>\n<h2 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h2><h3 id=\"从组件化到模块化\"><a href=\"#从组件化到模块化\" class=\"headerlink\" title=\"从组件化到模块化\"></a>从组件化到模块化</h3><p>Vue的组件化能力，缩短了开发周期。但纵览多条产品线的代码，依然存在很多职责相同的代码。比如好几个产品，各自实现了一套time-format模块。</p>\n<p>我们需要将公共代码，提取到模块，不同产品分别引用这个模块就好了。感谢社区为我们提供了完善的模块化能力。</p>\n<p>产品引入的iView，为大家竖立了榜样。团队成员，都要适度参与到开源社区，每各人都是前端生态的一部分。</p>\n<p>提倡渐进式地开发方式。大家在完成功能开发后，能够多一些思考，考虑哪些代码具有通用性，将这些代码提炼出去，最后 npm publish.</p>\n<p>希望每位工程师，不止于业务，向前一步。</p>\n<h3 id=\"从纯前端到大前端\"><a href=\"#从纯前端到大前端\" class=\"headerlink\" title=\"从纯前端到大前端\"></a>从纯前端到大前端</h3><p>工程师只会浏览器端的开发技术，就很难设计出功能完整的作品，创造力也因此受到了限制。团队鼓励大家，在掌握了前端的技能后，能够突破边界，再多涉及一些 Node 开发技术、多了解一些 Http 协议的常识。</p>\n<p>工程师站在大前端的高度，就能在不同的层面考虑问题，给出最适当的解决方案。比如为了提高产品发布的可靠性，要引入灰度发布流程，团队实现了完整的灰度分流和对应的配置平台。</p>\n<p>浏览器端和 Node 端，要关注的方面不同，团队不能因此失去专注。半年来，希望团队能够从单纯的前端团队，成长为大前端团队。按照二八原则，希望能有 20% 的团队成员能够专注在 Node 方面。对于其他队员，也希望能够在仿照固有的模式，开发一些 Node 端的代码。</p>\n<p>从这一想法出发，团队启动了 Flclover（四叶草）项目，一个基于 Koa 的企业级 Node 解决方案。</p>\n<p>目前 Flclover 稳定在 0.7.x 版本，已经在内部的两个项目，完成了验证。</p>\n<h3 id=\"从引入开源到生态共建\"><a href=\"#从引入开源到生态共建\" class=\"headerlink\" title=\"从引入开源到生态共建\"></a>从引入开源到生态共建</h3><p>Hats off to Github.</p>\n<p>团队中引入了大量的开源模块和工具，像 NodeJS、NPM、Webpack、Vue 和 iView 等，这些开源工具让大家可以更专注在业务上面，不需要花时间去研发这些基础的东西。</p>\n<p>在我刚入行的几年，除了业务研发，还需要花费大量的时间和精力，开发工具类的东西。像公共组件、模块加载器和打包工具等，如今所有这些，都可以在社区找到完整的解决方案。</p>\n<p>团队鼓励大家都参与到开源生态的共建，形成从引入到贡献良性的开源闭环。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>半年来，团队完成了规范的推广和技术架构的统一，这些为团队规模的迅速扩大，打好了基础。接下来，团队还要普及渐进式的开发方式，完成从纯前端到大前端团队的过度。</p>\n<p>加油 2017！</p>\n"},{"title":"渐进式全栈开发策略","date":"2017-06-16T03:18:25.000Z","_content":"\n渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。\n\n这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。\n\n最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。\n\n可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。\n\n原则上，在开发过程中应该尽量做到：\n1. 同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；\n2. 开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。\n3. 在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。\n\n\n前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：[语义化版本](http://semver.org/lang/zh-CN/)，[package.json规则](https://docs.npmjs.com/files/package.json)、[单元测试](https://mochajs.org/)、npm组件发布等等。\n\n但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。\n","source":"_posts/渐进式全栈开发策略.md","raw":"---\ntitle: 渐进式全栈开发策略\ndate: 2017-06-16 11:18:25\ntags: [全栈,Node]\n---\n\n渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。\n\n这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。\n\n最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。\n\n可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。\n\n原则上，在开发过程中应该尽量做到：\n1. 同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；\n2. 开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。\n3. 在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。\n\n\n前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：[语义化版本](http://semver.org/lang/zh-CN/)，[package.json规则](https://docs.npmjs.com/files/package.json)、[单元测试](https://mochajs.org/)、npm组件发布等等。\n\n但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。\n","slug":"渐进式全栈开发策略","published":1,"updated":"2017-06-22T10:08:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6kwxrl80001u1jinrdomug2","content":"<p>渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。</p>\n<p>这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。</p>\n<p>最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。</p>\n<p>可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。</p>\n<p>原则上，在开发过程中应该尽量做到：</p>\n<ol>\n<li>同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；</li>\n<li>开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。</li>\n<li>在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。</li>\n</ol>\n<p>前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本</a>，<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a>、<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">单元测试</a>、npm组件发布等等。</p>\n<p>但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。</p>\n<p>这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。</p>\n<p>最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。</p>\n<p>可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。</p>\n<p>原则上，在开发过程中应该尽量做到：</p>\n<ol>\n<li>同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；</li>\n<li>开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。</li>\n<li>在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。</li>\n</ol>\n<p>前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本</a>，<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a>、<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">单元测试</a>、npm组件发布等等。</p>\n<p>但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj6kwxrl40000u1jip5dficj5","tag_id":"cj6kwxrlb0002u1jiau0q33o1","_id":"cj6kwxrlf0009u1ji2fpjrjo2"},{"post_id":"cj6kwxrl40000u1jip5dficj5","tag_id":"cj6kwxrld0003u1jif6nf52u7","_id":"cj6kwxrlg000au1ji1nm3vp8v"},{"post_id":"cj6kwxrl40000u1jip5dficj5","tag_id":"cj6kwxrle0004u1jiho7mdtas","_id":"cj6kwxrlg000cu1jiw5qb5cyo"},{"post_id":"cj6kwxrl40000u1jip5dficj5","tag_id":"cj6kwxrle0005u1jitljvt5r2","_id":"cj6kwxrlg000du1jipiped9x8"},{"post_id":"cj6kwxrl40000u1jip5dficj5","tag_id":"cj6kwxrle0006u1jid0mqwegi","_id":"cj6kwxrlg000eu1ji4qk7u9zs"},{"post_id":"cj6kwxrl40000u1jip5dficj5","tag_id":"cj6kwxrle0007u1ji0m975393","_id":"cj6kwxrlg000fu1jigri362o7"},{"post_id":"cj6kwxrl80001u1jinrdomug2","tag_id":"cj6kwxrle0008u1jis05oemr5","_id":"cj6kwxrlg000gu1ji92f5xf6s"},{"post_id":"cj6kwxrl80001u1jinrdomug2","tag_id":"cj6kwxrlg000bu1jigd0gc31z","_id":"cj6kwxrlh000hu1jin8prwajm"}],"Tag":[{"name":"工程化","_id":"cj6kwxrlb0002u1jiau0q33o1"},{"name":"文档","_id":"cj6kwxrld0003u1jif6nf52u7"},{"name":"开源","_id":"cj6kwxrle0004u1jiho7mdtas"},{"name":"es6","_id":"cj6kwxrle0005u1jitljvt5r2"},{"name":"git","_id":"cj6kwxrle0006u1jid0mqwegi"},{"name":"eslint","_id":"cj6kwxrle0007u1ji0m975393"},{"name":"全栈","_id":"cj6kwxrle0008u1jis05oemr5"},{"name":"Node","_id":"cj6kwxrlg000bu1jigd0gc31z"}]}}