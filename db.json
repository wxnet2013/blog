{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/Hacker/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-heart.svg","path":"images/icon-heart.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/article.styl","path":"css/components/article.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/base/normalize.css","path":"css/base/normalize.css","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/categories.styl","path":"css/components/categories.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/archive.styl","path":"css/components/archive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/header.styl","path":"css/components/header.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/footer.styl","path":"css/components/footer.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/responsive.styl","path":"css/components/responsive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/icon.styl","path":"css/components/icon.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/layout.styl","path":"css/components/layout.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/pagination.styl","path":"css/components/pagination.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/tags.styl","path":"css/components/tags.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/syntax.styl","path":"css/components/syntax.styl","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"d3af5b9b062d55a5445af8908c3a1671e35639a1","modified":1497240939000},{"_id":"themes/Hacker/.gitignore","hash":"803c06a7086b5817c03d2e8672da27bc56ba2bce","modified":1485843797000},{"_id":"themes/Hacker/_config.yml","hash":"5d8cc859c48024451a316c50ab16ba58702b062d","modified":1485843797000},{"_id":"themes/Hacker/README_zh-CN.md","hash":"d6c9200e96bb3633c3a84de169f91e6c34a5ea14","modified":1485843797000},{"_id":"themes/Hacker/README.md","hash":"71077f7bdebc6e8d36f763e715ec2d55ddca4141","modified":1485843797000},{"_id":"themes/Hacker/LICENSE","hash":"3127907a7623734f830e8c69ccee03b693bf993e","modified":1485843797000},{"_id":"source/_posts/前端工程化实践.md","hash":"8cb2fc549888df560b2f3de693345ba7ca3e373f","modified":1503044732000},{"_id":"source/_posts/渐进式全栈开发策略.md","hash":"4dc1b0717dc45b403666bea02c2e7c4a611a3ee7","modified":1498126115000},{"_id":"themes/Hacker/languages/zh-CN.yml","hash":"18638177b944e0deb4a8c26a1c4a980901151132","modified":1485843797000},{"_id":"themes/Hacker/languages/default.yml","hash":"ef90548952b1f9cc88dbe9daad882786212aec38","modified":1485843797000},{"_id":"themes/Hacker/layout/archive.ejs","hash":"2238cbe29009aafb16969d2c70dceb3f71772123","modified":1485843797000},{"_id":"themes/Hacker/layout/categories.ejs","hash":"bfad4e7eade650c535f0194974e2646619657b8b","modified":1485843797000},{"_id":"themes/Hacker/layout/page.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1485843797000},{"_id":"themes/Hacker/layout/layout.ejs","hash":"341e77b5f07457e4ccd69634f511da05a5d89f18","modified":1485843797000},{"_id":"themes/Hacker/layout/index.ejs","hash":"1d2c487a95d25e763b5f7e004194eb6ee6b18135","modified":1485843797000},{"_id":"themes/Hacker/layout/tags.ejs","hash":"ee89e6a9c14bdb5e5e8cf975a558c780fe8dabff","modified":1485843797000},{"_id":"themes/Hacker/layout/post.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1485843797000},{"_id":"themes/Hacker/layout/components/archive.ejs","hash":"1f79ebaf52b8229cf5c58bb8325cf0177859a05c","modified":1485843797000},{"_id":"themes/Hacker/layout/components/article.ejs","hash":"5a08e05eb271589a2ed69fdd08516fa8457af3ed","modified":1485843797000},{"_id":"themes/Hacker/layout/components/categories.ejs","hash":"3665bf5d1c7181db22dc1c48d62ebf42757d8c27","modified":1485843797000},{"_id":"themes/Hacker/layout/components/comment.ejs","hash":"34b72f9819b5298be101f5c568cc7f2a52ab0f7d","modified":1485843797000},{"_id":"themes/Hacker/layout/components/footer.ejs","hash":"538795f4af3a98e824aefc4b68a1bcd210c091e9","modified":1485843797000},{"_id":"themes/Hacker/layout/components/googleanalytics.ejs","hash":"fa11251ace0fc61cbcffb74f32fbf5bdbb201ff2","modified":1485843797000},{"_id":"themes/Hacker/layout/components/head.ejs","hash":"10475fdfc513c9380f18d034e15b3b051c8e9269","modified":1485843797000},{"_id":"themes/Hacker/layout/components/header.ejs","hash":"929a8eafa278d49c2f41d3581e2608eca80d7856","modified":1485843797000},{"_id":"themes/Hacker/layout/components/pagination.ejs","hash":"4ab5e3b0239e467923a0f91c771bcc9ee7889cfe","modified":1485843797000},{"_id":"themes/Hacker/source/css/style.styl","hash":"208e5f6d010e4e2c5590dae5e4fca8de592d3ef1","modified":1485843797000},{"_id":"themes/Hacker/source/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/article.styl","hash":"e99f13c6744ddaa7f7bfcf0662e4dc6840fae8fa","modified":1485843797000},{"_id":"themes/Hacker/source/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/categories.styl","hash":"c67e20d60351295cb178b568af42d430f4bcc3e6","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/archive.styl","hash":"de701a1dee6e870140565044a08c2c45cfcd4bc3","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/header.styl","hash":"fa5e6d715d288a327406df78225284c70530cb98","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/footer.styl","hash":"80ef890252d31d3bbfe71740fdcfc54ae14cad8e","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/responsive.styl","hash":"053e7ec4c22845422440660b7e1d6b0dea5b4fbd","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/icon.styl","hash":"8da3ff5b6cd1609fdfe0c564d47391367abc8808","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/layout.styl","hash":"73c1688b95b20cd67669bc5567420f5be8448c9f","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/pagination.styl","hash":"c20a9920bb444c22b20e588f97eba4e03f09a439","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/tags.styl","hash":"684cf4eb4b8671476365e955dceebf096cc0e6ed","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/syntax.styl","hash":"68b7deadab1ac13603eb5e812e1060db25227fd0","modified":1485843797000},{"_id":"public/2017/08/18/前端工程化实践/index.html","hash":"8fbbbe56b96271f06ec509746df80130a0b865a3","modified":1503044750180},{"_id":"public/2017/06/16/渐进式全栈开发策略/index.html","hash":"d2480e5e95f77ad0f2085b413fa0389e1b225ef8","modified":1503044750180},{"_id":"public/archives/index.html","hash":"8f28423feea0c822f2adb31e0f361eb87572b09c","modified":1503044750181},{"_id":"public/archives/2017/index.html","hash":"01de55775645df9ef01e66538e3a1e9627e70c8e","modified":1503044750181},{"_id":"public/archives/2017/06/index.html","hash":"5c9edd23567352ca2b66938dbaff8c15f8c1bb81","modified":1503044750181},{"_id":"public/archives/2017/08/index.html","hash":"3de32d66e7ce53b93b7bc5a92da5837df11cd8ca","modified":1503044750181},{"_id":"public/tags/草稿/index.html","hash":"efdd487ce30d1b368d3037632342a8a00e241dc5","modified":1503044750181},{"_id":"public/tags/全栈/index.html","hash":"f85c553d641d299b58d7f22275cbc0a7716a67db","modified":1503044750181},{"_id":"public/tags/Node/index.html","hash":"03e8c6c87b8070471f2e9fb899bb35f20a2bca28","modified":1503044750181},{"_id":"public/index.html","hash":"2e4d63a21026ef8ef06948793900cdcc05a4f27a","modified":1503044750181},{"_id":"public/tags/工程化/index.html","hash":"2bd9fc03ea3b95e513caabac66d96821a17d3916","modified":1503044750442},{"_id":"public/tags/eslint/index.html","hash":"bb78cc6a9f924906451293171e3c76ab83ea11f7","modified":1503044750442},{"_id":"public/tags/git/index.html","hash":"5c2b2204ae06051e7a856c2c139fd2b451892607","modified":1503044750444},{"_id":"public/CNAME","hash":"d3af5b9b062d55a5445af8908c3a1671e35639a1","modified":1503044750444},{"_id":"public/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1503044750450},{"_id":"public/css/components/article.css","hash":"563b6fd19e1f5ba4787acd2ef2e1ee876e521cab","modified":1503044750999},{"_id":"public/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1503044751000},{"_id":"public/css/components/categories.css","hash":"f181d27640f1408f032c5386836c4c2322724f8d","modified":1503044751000},{"_id":"public/css/components/archive.css","hash":"14902abf01556a3e23e03ac18c87fa7a5a39d89a","modified":1503044751000},{"_id":"public/css/components/header.css","hash":"51f8a4c736f3b180a7c4c8f804d8060031df6a34","modified":1503044751000},{"_id":"public/css/components/footer.css","hash":"602def895fd52f288b6e93932284aa2e52b7fee0","modified":1503044751000},{"_id":"public/css/components/responsive.css","hash":"216eb94fc69007de995fc8d382670ba00a9574e8","modified":1503044751000},{"_id":"public/css/components/icon.css","hash":"cdaf1a152184ff7def760f14095e4a2fa16cd6bd","modified":1503044751000},{"_id":"public/css/components/layout.css","hash":"b8625c7b90a973f2e37897f346e6f80b779fd9ca","modified":1503044751000},{"_id":"public/css/components/pagination.css","hash":"2f3f9bb1bc6513d08865e7a2fb2160cc47d4a229","modified":1503044751000},{"_id":"public/css/components/tags.css","hash":"1566e94c23ae19dbfc7d2cf433e68242ed657dea","modified":1503044751000},{"_id":"public/css/components/syntax.css","hash":"00970bfdb168aa13622c829920907ca3416829f8","modified":1503044751000},{"_id":"public/css/style.css","hash":"48373889a036d403ca34bc085cabeb302e2a08ee","modified":1503044751000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"前端工程化实践","date":"2017-08-17T16:00:00.000Z","_content":"\n# DTU前端工程化实践\n年初入职TalkingData，到现在半年有余。感谢TD的充分信任和赋权，使我可以大胆尝试。整个部门几条产品线，如果技术栈、规范不统一，后期产品的迭代会很难进行下去。在组件化、git规范、代码规范和自动化方面引入了很多现成的方案。\n\n## 组件化\n如今的前端开发，已不是简单的页面制作加上jQuery，就能满足业务要求了。前端工程师要面对的不只是简单的网站，而是复杂的web应用。各产品需要更好的用户体验，团队选择了最为复杂的单页应用SPA，需要对代码质量有更高的要求，才能保证产品有好的体验。\n\n### 各产品线统一为Vue技术栈\n在前端框架领域，已是React、Angular和Vue三分天下，这些框架为前端组件化提供了很好的支持，团队选择使用Vue技术栈。\n统一技术栈有很多好处，可以降低不同产品间人员调整的成本，可以在产品间共享组件和模块代码。\n\n### 采用组件化的方式快速迭代产品\n产品迭代的速度，很大程度上决定了产品成败。组件化的前端开发理念，可以快速的拼装出产品，每个组件都可以独立升级和替换。\n前端组件是页面上可复用的UI单元，比如信息区块、页头、页尾、导航等。工程正式开发之前，我们仔细研究了设计图，统计出整个产品包含哪些组件，哪些组件可复用程度更高。\n优先开发复用度更高的组件，完成后快速拼装出功能页面。不难想到，前端开发的效率取决于设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。\n智能数据市场产品（SDMK）在开发初期，就选择了组件化的开发方式，很大的缩短了产品迭代周期。\n(图片制作： 页面A --- 组件A --- 页面B)\n\n## git规范化\n团队中的几位工程师分工协作完成不同的功能组件，需要规范的代码管理流程，减少代码冲突和持续的功能集成。\n\n### 规范化的git工作流\n高效的开发团队，需要规范化的代码管理流程做保证，团队直接沿用了成熟的开发流程，并采用了每日集成的开发策略。\n\n在产品开发阶段，每位工程师在自己开发分支下快速开发，每天在固定的时间，由组长将代码集成到daily分支。在集成的过程中，会进行CodeReview，检查代码规范和逻辑的部分。\n\n完成集成后，执行Jenkins的构建过程。\n\n产品上线后，进入功能迭代阶段，工程师的dev分支转换为feature分支。\n\n每天完成计划的部分，定时集成到daily分支，并部署到daily环境。\n\n大家每天的工作目标明确，成果可见，每天都很有成就感。\n\n（图片：git工作流图）\n\n### git提交规范\n在每天构建的过程中，要对代码进行快速Review，一般会快速浏览gitlab中的提交记录，规范化的Commit message，为每天的Code Review提供了保证。\n\n一次代码提交应该做到原子性：完成一个bug的修改、一个功能的文档、一次重构等等。\n\n好的代码提交说明，应该完全匹配修改的内容，最好能够包含对修改的部分、类型给出明确的说明。\n\n（gitlab截图：）\n\n> fix(service):服务编辑时没有去掉可见性字段校验\n\n我们直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有现成配套的工具。\n\n（工具图片）\n\nAngular规范：\n```\nfeat：新功能（feature）\nfix：修补bug\ndocs：文档（documentation）\nstyle： 格式（不影响代码运行的变动）\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：构建过程或辅助工具的变动\n```\n格式化的Commit message，有几个好处。\n\n1. 提供更多的历史信息，方便代码CodeReview。\n2. 可以过滤commit，快速查找信息。\n3. 还可以由提交说明生成产品的changelog。\n\n（Jenkins截图）\n\n## 代码规范化\n组建一只规范化的前端团队，是我转型技术管理第一目标：产品代码看起来像是是由一个人写的，代码和注释风格要统一。\n\n### JavaScript的语言升级和规范化\n过于灵活的ES5，并不适合企业级web应用开发。\n\n由于产品存在历史代码，所以大家需要循序渐进的由ES5迁移到ES6下，比如新功能代码，禁止使用var声明变量，而改为使用let或const。\n\n对于函数的声明，鼓励去掉function关键字，更多的使用箭头函数，尝试使用函数的默认值；\n\n用模版字符串替换掉之前的字符串拼接；\n\n逐渐深入使用ES6的更多的特性，整个迁移过程平滑自然。\n\n在引入ES6语言的同时，引入了目前广泛使用和成熟的Airbnb语言规范，有现成的规\n\n范文档。引入eslint工具，保证大家代码的规范性。在编辑和“编译”阶段，项目中引入相关eslint组件，自动检查代码的风格是否符合规范。\n\n对不符合规范的代码，会给出错误提示，并不能执行代码。\n\n大家在学习Airbnb的规范的同时，对照ES5和ES6的写法，快速完成语言的切换。\n\n下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效。\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n### CSS预处理器SASS\n样式预处理器SASS，为CSS带来了编程语言的能力，比如变量、函数和模块化。使用SASS能够很大程度上提高代码的复用度。\n\nJavaScript有eslint检查工具，对于SASS可以使用stylelint检查代码，\n\n遗憾的是社区开源的编辑器插件不是很完善，只找到了atom版本。\n\n### HTMl的规范化\n技术架构统一为Vue2.x，很遗憾没有找到Vue中HTML的规范化工具，后期会进行引入或研究开源。\n\n\n## 组件化到模块化再到开源贡献\nVue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。\n每个产品都有自己的一套time-format模块，不同产品线，重复劳动太多。\n\n团队不仅仅需要组件化，我们需要将公共代码进行模块化，感谢Node社区。\n\n各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。\n\n希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。\n\n不止于业务，向前一步。\n\n在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。\n\n## 源代码即文档\n设计了声明式的model层，从代码中直观的看到接口协议，地址和参数规则等。\n```\n// define api\nexport const addInternalGroup = schema.post('/path/to/action', {\n  name: { type: String, required: true },\n  info: { type: String, required: true },\n});\n\n// use api\naddInternalGroup({ name: 'xxx', info: 'xxx' }).then((json) => {\n  log(json);  \n});\n```\n开源了apischema https://www.npmjs.com/package/apischema\n\n## 从前端到大前端之路\n\n工程师要竖立前端大局观，从不同的角度考虑技术方案。\n\n用前端的方案实现产品的灰度分流和配置。\n\n基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。\n\n后期会优先在分析线落地。\n\n## 最后\n在前端工程化方面还有很长的路要走，持续学习和进步。\n\n加油2017！\n","source":"_posts/前端工程化实践.md","raw":"---\ntitle: 前端工程化实践\ndate: 2017-08-18 00:00\ntags: [草稿,工程化,git,eslint]\n---\n\n# DTU前端工程化实践\n年初入职TalkingData，到现在半年有余。感谢TD的充分信任和赋权，使我可以大胆尝试。整个部门几条产品线，如果技术栈、规范不统一，后期产品的迭代会很难进行下去。在组件化、git规范、代码规范和自动化方面引入了很多现成的方案。\n\n## 组件化\n如今的前端开发，已不是简单的页面制作加上jQuery，就能满足业务要求了。前端工程师要面对的不只是简单的网站，而是复杂的web应用。各产品需要更好的用户体验，团队选择了最为复杂的单页应用SPA，需要对代码质量有更高的要求，才能保证产品有好的体验。\n\n### 各产品线统一为Vue技术栈\n在前端框架领域，已是React、Angular和Vue三分天下，这些框架为前端组件化提供了很好的支持，团队选择使用Vue技术栈。\n统一技术栈有很多好处，可以降低不同产品间人员调整的成本，可以在产品间共享组件和模块代码。\n\n### 采用组件化的方式快速迭代产品\n产品迭代的速度，很大程度上决定了产品成败。组件化的前端开发理念，可以快速的拼装出产品，每个组件都可以独立升级和替换。\n前端组件是页面上可复用的UI单元，比如信息区块、页头、页尾、导航等。工程正式开发之前，我们仔细研究了设计图，统计出整个产品包含哪些组件，哪些组件可复用程度更高。\n优先开发复用度更高的组件，完成后快速拼装出功能页面。不难想到，前端开发的效率取决于设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。\n智能数据市场产品（SDMK）在开发初期，就选择了组件化的开发方式，很大的缩短了产品迭代周期。\n(图片制作： 页面A --- 组件A --- 页面B)\n\n## git规范化\n团队中的几位工程师分工协作完成不同的功能组件，需要规范的代码管理流程，减少代码冲突和持续的功能集成。\n\n### 规范化的git工作流\n高效的开发团队，需要规范化的代码管理流程做保证，团队直接沿用了成熟的开发流程，并采用了每日集成的开发策略。\n\n在产品开发阶段，每位工程师在自己开发分支下快速开发，每天在固定的时间，由组长将代码集成到daily分支。在集成的过程中，会进行CodeReview，检查代码规范和逻辑的部分。\n\n完成集成后，执行Jenkins的构建过程。\n\n产品上线后，进入功能迭代阶段，工程师的dev分支转换为feature分支。\n\n每天完成计划的部分，定时集成到daily分支，并部署到daily环境。\n\n大家每天的工作目标明确，成果可见，每天都很有成就感。\n\n（图片：git工作流图）\n\n### git提交规范\n在每天构建的过程中，要对代码进行快速Review，一般会快速浏览gitlab中的提交记录，规范化的Commit message，为每天的Code Review提供了保证。\n\n一次代码提交应该做到原子性：完成一个bug的修改、一个功能的文档、一次重构等等。\n\n好的代码提交说明，应该完全匹配修改的内容，最好能够包含对修改的部分、类型给出明确的说明。\n\n（gitlab截图：）\n\n> fix(service):服务编辑时没有去掉可见性字段校验\n\n我们直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有现成配套的工具。\n\n（工具图片）\n\nAngular规范：\n```\nfeat：新功能（feature）\nfix：修补bug\ndocs：文档（documentation）\nstyle： 格式（不影响代码运行的变动）\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：构建过程或辅助工具的变动\n```\n格式化的Commit message，有几个好处。\n\n1. 提供更多的历史信息，方便代码CodeReview。\n2. 可以过滤commit，快速查找信息。\n3. 还可以由提交说明生成产品的changelog。\n\n（Jenkins截图）\n\n## 代码规范化\n组建一只规范化的前端团队，是我转型技术管理第一目标：产品代码看起来像是是由一个人写的，代码和注释风格要统一。\n\n### JavaScript的语言升级和规范化\n过于灵活的ES5，并不适合企业级web应用开发。\n\n由于产品存在历史代码，所以大家需要循序渐进的由ES5迁移到ES6下，比如新功能代码，禁止使用var声明变量，而改为使用let或const。\n\n对于函数的声明，鼓励去掉function关键字，更多的使用箭头函数，尝试使用函数的默认值；\n\n用模版字符串替换掉之前的字符串拼接；\n\n逐渐深入使用ES6的更多的特性，整个迁移过程平滑自然。\n\n在引入ES6语言的同时，引入了目前广泛使用和成熟的Airbnb语言规范，有现成的规\n\n范文档。引入eslint工具，保证大家代码的规范性。在编辑和“编译”阶段，项目中引入相关eslint组件，自动检查代码的风格是否符合规范。\n\n对不符合规范的代码，会给出错误提示，并不能执行代码。\n\n大家在学习Airbnb的规范的同时，对照ES5和ES6的写法，快速完成语言的切换。\n\n下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效。\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n### CSS预处理器SASS\n样式预处理器SASS，为CSS带来了编程语言的能力，比如变量、函数和模块化。使用SASS能够很大程度上提高代码的复用度。\n\nJavaScript有eslint检查工具，对于SASS可以使用stylelint检查代码，\n\n遗憾的是社区开源的编辑器插件不是很完善，只找到了atom版本。\n\n### HTMl的规范化\n技术架构统一为Vue2.x，很遗憾没有找到Vue中HTML的规范化工具，后期会进行引入或研究开源。\n\n\n## 组件化到模块化再到开源贡献\nVue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。\n每个产品都有自己的一套time-format模块，不同产品线，重复劳动太多。\n\n团队不仅仅需要组件化，我们需要将公共代码进行模块化，感谢Node社区。\n\n各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。\n\n希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。\n\n不止于业务，向前一步。\n\n在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。\n\n## 源代码即文档\n设计了声明式的model层，从代码中直观的看到接口协议，地址和参数规则等。\n```\n// define api\nexport const addInternalGroup = schema.post('/path/to/action', {\n  name: { type: String, required: true },\n  info: { type: String, required: true },\n});\n\n// use api\naddInternalGroup({ name: 'xxx', info: 'xxx' }).then((json) => {\n  log(json);  \n});\n```\n开源了apischema https://www.npmjs.com/package/apischema\n\n## 从前端到大前端之路\n\n工程师要竖立前端大局观，从不同的角度考虑技术方案。\n\n用前端的方案实现产品的灰度分流和配置。\n\n基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。\n\n后期会优先在分析线落地。\n\n## 最后\n在前端工程化方面还有很长的路要走，持续学习和进步。\n\n加油2017！\n","slug":"前端工程化实践","published":1,"updated":"2017-08-18T08:25:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6hm1b460000ertxxfigt09t","content":"<h1 id=\"DTU前端工程化实践\"><a href=\"#DTU前端工程化实践\" class=\"headerlink\" title=\"DTU前端工程化实践\"></a>DTU前端工程化实践</h1><p>年初入职TalkingData，到现在半年有余。感谢TD的充分信任和赋权，使我可以大胆尝试。整个部门几条产品线，如果技术栈、规范不统一，后期产品的迭代会很难进行下去。在组件化、git规范、代码规范和自动化方面引入了很多现成的方案。</p>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><p>如今的前端开发，已不是简单的页面制作加上jQuery，就能满足业务要求了。前端工程师要面对的不只是简单的网站，而是复杂的web应用。各产品需要更好的用户体验，团队选择了最为复杂的单页应用SPA，需要对代码质量有更高的要求，才能保证产品有好的体验。</p>\n<h3 id=\"各产品线统一为Vue技术栈\"><a href=\"#各产品线统一为Vue技术栈\" class=\"headerlink\" title=\"各产品线统一为Vue技术栈\"></a>各产品线统一为Vue技术栈</h3><p>在前端框架领域，已是React、Angular和Vue三分天下，这些框架为前端组件化提供了很好的支持，团队选择使用Vue技术栈。<br>统一技术栈有很多好处，可以降低不同产品间人员调整的成本，可以在产品间共享组件和模块代码。</p>\n<h3 id=\"采用组件化的方式快速迭代产品\"><a href=\"#采用组件化的方式快速迭代产品\" class=\"headerlink\" title=\"采用组件化的方式快速迭代产品\"></a>采用组件化的方式快速迭代产品</h3><p>产品迭代的速度，很大程度上决定了产品成败。组件化的前端开发理念，可以快速的拼装出产品，每个组件都可以独立升级和替换。<br>前端组件是页面上可复用的UI单元，比如信息区块、页头、页尾、导航等。工程正式开发之前，我们仔细研究了设计图，统计出整个产品包含哪些组件，哪些组件可复用程度更高。<br>优先开发复用度更高的组件，完成后快速拼装出功能页面。不难想到，前端开发的效率取决于设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。<br>智能数据市场产品（SDMK）在开发初期，就选择了组件化的开发方式，很大的缩短了产品迭代周期。<br>(图片制作： 页面A — 组件A — 页面B)</p>\n<h2 id=\"git规范化\"><a href=\"#git规范化\" class=\"headerlink\" title=\"git规范化\"></a>git规范化</h2><p>团队中的几位工程师分工协作完成不同的功能组件，需要规范的代码管理流程，减少代码冲突和持续的功能集成。</p>\n<h3 id=\"规范化的git工作流\"><a href=\"#规范化的git工作流\" class=\"headerlink\" title=\"规范化的git工作流\"></a>规范化的git工作流</h3><p>高效的开发团队，需要规范化的代码管理流程做保证，团队直接沿用了成熟的开发流程，并采用了每日集成的开发策略。</p>\n<p>在产品开发阶段，每位工程师在自己开发分支下快速开发，每天在固定的时间，由组长将代码集成到daily分支。在集成的过程中，会进行CodeReview，检查代码规范和逻辑的部分。</p>\n<p>完成集成后，执行Jenkins的构建过程。</p>\n<p>产品上线后，进入功能迭代阶段，工程师的dev分支转换为feature分支。</p>\n<p>每天完成计划的部分，定时集成到daily分支，并部署到daily环境。</p>\n<p>大家每天的工作目标明确，成果可见，每天都很有成就感。</p>\n<p>（图片：git工作流图）</p>\n<h3 id=\"git提交规范\"><a href=\"#git提交规范\" class=\"headerlink\" title=\"git提交规范\"></a>git提交规范</h3><p>在每天构建的过程中，要对代码进行快速Review，一般会快速浏览gitlab中的提交记录，规范化的Commit message，为每天的Code Review提供了保证。</p>\n<p>一次代码提交应该做到原子性：完成一个bug的修改、一个功能的文档、一次重构等等。</p>\n<p>好的代码提交说明，应该完全匹配修改的内容，最好能够包含对修改的部分、类型给出明确的说明。</p>\n<p>（gitlab截图：）</p>\n<blockquote>\n<p>fix(service):服务编辑时没有去掉可见性字段校验</p>\n</blockquote>\n<p>我们直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有现成配套的工具。</p>\n<p>（工具图片）</p>\n<p>Angular规范：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">feat：新功能（feature）</div><div class=\"line\">fix：修补bug</div><div class=\"line\">docs：文档（documentation）</div><div class=\"line\">style： 格式（不影响代码运行的变动）</div><div class=\"line\">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</div><div class=\"line\">test：增加测试</div><div class=\"line\">chore：构建过程或辅助工具的变动</div></pre></td></tr></table></figure></p>\n<p>格式化的Commit message，有几个好处。</p>\n<ol>\n<li>提供更多的历史信息，方便代码CodeReview。</li>\n<li>可以过滤commit，快速查找信息。</li>\n<li>还可以由提交说明生成产品的changelog。</li>\n</ol>\n<p>（Jenkins截图）</p>\n<h2 id=\"代码规范化\"><a href=\"#代码规范化\" class=\"headerlink\" title=\"代码规范化\"></a>代码规范化</h2><p>组建一只规范化的前端团队，是我转型技术管理第一目标：产品代码看起来像是是由一个人写的，代码和注释风格要统一。</p>\n<h3 id=\"JavaScript的语言升级和规范化\"><a href=\"#JavaScript的语言升级和规范化\" class=\"headerlink\" title=\"JavaScript的语言升级和规范化\"></a>JavaScript的语言升级和规范化</h3><p>过于灵活的ES5，并不适合企业级web应用开发。</p>\n<p>由于产品存在历史代码，所以大家需要循序渐进的由ES5迁移到ES6下，比如新功能代码，禁止使用var声明变量，而改为使用let或const。</p>\n<p>对于函数的声明，鼓励去掉function关键字，更多的使用箭头函数，尝试使用函数的默认值；</p>\n<p>用模版字符串替换掉之前的字符串拼接；</p>\n<p>逐渐深入使用ES6的更多的特性，整个迁移过程平滑自然。</p>\n<p>在引入ES6语言的同时，引入了目前广泛使用和成熟的Airbnb语言规范，有现成的规</p>\n<p>范文档。引入eslint工具，保证大家代码的规范性。在编辑和“编译”阶段，项目中引入相关eslint组件，自动检查代码的风格是否符合规范。</p>\n<p>对不符合规范的代码，会给出错误提示，并不能执行代码。</p>\n<p>大家在学习Airbnb的规范的同时，对照ES5和ES6的写法，快速完成语言的切换。</p>\n<p>下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\"><span class=\"keyword\">const</span> len = items.length;</div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [];</div><div class=\"line\"><span class=\"keyword\">let</span> i;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">  itemsCopy[i] = items[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>\n<h3 id=\"CSS预处理器SASS\"><a href=\"#CSS预处理器SASS\" class=\"headerlink\" title=\"CSS预处理器SASS\"></a>CSS预处理器SASS</h3><p>样式预处理器SASS，为CSS带来了编程语言的能力，比如变量、函数和模块化。使用SASS能够很大程度上提高代码的复用度。</p>\n<p>JavaScript有eslint检查工具，对于SASS可以使用stylelint检查代码，</p>\n<p>遗憾的是社区开源的编辑器插件不是很完善，只找到了atom版本。</p>\n<h3 id=\"HTMl的规范化\"><a href=\"#HTMl的规范化\" class=\"headerlink\" title=\"HTMl的规范化\"></a>HTMl的规范化</h3><p>技术架构统一为Vue2.x，很遗憾没有找到Vue中HTML的规范化工具，后期会进行引入或研究开源。</p>\n<h2 id=\"组件化到模块化再到开源贡献\"><a href=\"#组件化到模块化再到开源贡献\" class=\"headerlink\" title=\"组件化到模块化再到开源贡献\"></a>组件化到模块化再到开源贡献</h2><p>Vue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。<br>每个产品都有自己的一套time-format模块，不同产品线，重复劳动太多。</p>\n<p>团队不仅仅需要组件化，我们需要将公共代码进行模块化，感谢Node社区。</p>\n<p>各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。</p>\n<p>希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。</p>\n<p>不止于业务，向前一步。</p>\n<p>在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。</p>\n<h2 id=\"源代码即文档\"><a href=\"#源代码即文档\" class=\"headerlink\" title=\"源代码即文档\"></a>源代码即文档</h2><p>设计了声明式的model层，从代码中直观的看到接口协议，地址和参数规则等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// define api</div><div class=\"line\">export const addInternalGroup = schema.post(&apos;/path/to/action&apos;, &#123;</div><div class=\"line\">  name: &#123; type: String, required: true &#125;,</div><div class=\"line\">  info: &#123; type: String, required: true &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// use api</div><div class=\"line\">addInternalGroup(&#123; name: &apos;xxx&apos;, info: &apos;xxx&apos; &#125;).then((json) =&gt; &#123;</div><div class=\"line\">  log(json);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>开源了apischema <a href=\"https://www.npmjs.com/package/apischema\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/apischema</a></p>\n<h2 id=\"从前端到大前端之路\"><a href=\"#从前端到大前端之路\" class=\"headerlink\" title=\"从前端到大前端之路\"></a>从前端到大前端之路</h2><p>工程师要竖立前端大局观，从不同的角度考虑技术方案。</p>\n<p>用前端的方案实现产品的灰度分流和配置。</p>\n<p>基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。</p>\n<p>后期会优先在分析线落地。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>在前端工程化方面还有很长的路要走，持续学习和进步。</p>\n<p>加油2017！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DTU前端工程化实践\"><a href=\"#DTU前端工程化实践\" class=\"headerlink\" title=\"DTU前端工程化实践\"></a>DTU前端工程化实践</h1><p>年初入职TalkingData，到现在半年有余。感谢TD的充分信任和赋权，使我可以大胆尝试。整个部门几条产品线，如果技术栈、规范不统一，后期产品的迭代会很难进行下去。在组件化、git规范、代码规范和自动化方面引入了很多现成的方案。</p>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><p>如今的前端开发，已不是简单的页面制作加上jQuery，就能满足业务要求了。前端工程师要面对的不只是简单的网站，而是复杂的web应用。各产品需要更好的用户体验，团队选择了最为复杂的单页应用SPA，需要对代码质量有更高的要求，才能保证产品有好的体验。</p>\n<h3 id=\"各产品线统一为Vue技术栈\"><a href=\"#各产品线统一为Vue技术栈\" class=\"headerlink\" title=\"各产品线统一为Vue技术栈\"></a>各产品线统一为Vue技术栈</h3><p>在前端框架领域，已是React、Angular和Vue三分天下，这些框架为前端组件化提供了很好的支持，团队选择使用Vue技术栈。<br>统一技术栈有很多好处，可以降低不同产品间人员调整的成本，可以在产品间共享组件和模块代码。</p>\n<h3 id=\"采用组件化的方式快速迭代产品\"><a href=\"#采用组件化的方式快速迭代产品\" class=\"headerlink\" title=\"采用组件化的方式快速迭代产品\"></a>采用组件化的方式快速迭代产品</h3><p>产品迭代的速度，很大程度上决定了产品成败。组件化的前端开发理念，可以快速的拼装出产品，每个组件都可以独立升级和替换。<br>前端组件是页面上可复用的UI单元，比如信息区块、页头、页尾、导航等。工程正式开发之前，我们仔细研究了设计图，统计出整个产品包含哪些组件，哪些组件可复用程度更高。<br>优先开发复用度更高的组件，完成后快速拼装出功能页面。不难想到，前端开发的效率取决于设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。<br>智能数据市场产品（SDMK）在开发初期，就选择了组件化的开发方式，很大的缩短了产品迭代周期。<br>(图片制作： 页面A — 组件A — 页面B)</p>\n<h2 id=\"git规范化\"><a href=\"#git规范化\" class=\"headerlink\" title=\"git规范化\"></a>git规范化</h2><p>团队中的几位工程师分工协作完成不同的功能组件，需要规范的代码管理流程，减少代码冲突和持续的功能集成。</p>\n<h3 id=\"规范化的git工作流\"><a href=\"#规范化的git工作流\" class=\"headerlink\" title=\"规范化的git工作流\"></a>规范化的git工作流</h3><p>高效的开发团队，需要规范化的代码管理流程做保证，团队直接沿用了成熟的开发流程，并采用了每日集成的开发策略。</p>\n<p>在产品开发阶段，每位工程师在自己开发分支下快速开发，每天在固定的时间，由组长将代码集成到daily分支。在集成的过程中，会进行CodeReview，检查代码规范和逻辑的部分。</p>\n<p>完成集成后，执行Jenkins的构建过程。</p>\n<p>产品上线后，进入功能迭代阶段，工程师的dev分支转换为feature分支。</p>\n<p>每天完成计划的部分，定时集成到daily分支，并部署到daily环境。</p>\n<p>大家每天的工作目标明确，成果可见，每天都很有成就感。</p>\n<p>（图片：git工作流图）</p>\n<h3 id=\"git提交规范\"><a href=\"#git提交规范\" class=\"headerlink\" title=\"git提交规范\"></a>git提交规范</h3><p>在每天构建的过程中，要对代码进行快速Review，一般会快速浏览gitlab中的提交记录，规范化的Commit message，为每天的Code Review提供了保证。</p>\n<p>一次代码提交应该做到原子性：完成一个bug的修改、一个功能的文档、一次重构等等。</p>\n<p>好的代码提交说明，应该完全匹配修改的内容，最好能够包含对修改的部分、类型给出明确的说明。</p>\n<p>（gitlab截图：）</p>\n<blockquote>\n<p>fix(service):服务编辑时没有去掉可见性字段校验</p>\n</blockquote>\n<p>我们直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有现成配套的工具。</p>\n<p>（工具图片）</p>\n<p>Angular规范：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">feat：新功能（feature）</div><div class=\"line\">fix：修补bug</div><div class=\"line\">docs：文档（documentation）</div><div class=\"line\">style： 格式（不影响代码运行的变动）</div><div class=\"line\">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</div><div class=\"line\">test：增加测试</div><div class=\"line\">chore：构建过程或辅助工具的变动</div></pre></td></tr></table></figure></p>\n<p>格式化的Commit message，有几个好处。</p>\n<ol>\n<li>提供更多的历史信息，方便代码CodeReview。</li>\n<li>可以过滤commit，快速查找信息。</li>\n<li>还可以由提交说明生成产品的changelog。</li>\n</ol>\n<p>（Jenkins截图）</p>\n<h2 id=\"代码规范化\"><a href=\"#代码规范化\" class=\"headerlink\" title=\"代码规范化\"></a>代码规范化</h2><p>组建一只规范化的前端团队，是我转型技术管理第一目标：产品代码看起来像是是由一个人写的，代码和注释风格要统一。</p>\n<h3 id=\"JavaScript的语言升级和规范化\"><a href=\"#JavaScript的语言升级和规范化\" class=\"headerlink\" title=\"JavaScript的语言升级和规范化\"></a>JavaScript的语言升级和规范化</h3><p>过于灵活的ES5，并不适合企业级web应用开发。</p>\n<p>由于产品存在历史代码，所以大家需要循序渐进的由ES5迁移到ES6下，比如新功能代码，禁止使用var声明变量，而改为使用let或const。</p>\n<p>对于函数的声明，鼓励去掉function关键字，更多的使用箭头函数，尝试使用函数的默认值；</p>\n<p>用模版字符串替换掉之前的字符串拼接；</p>\n<p>逐渐深入使用ES6的更多的特性，整个迁移过程平滑自然。</p>\n<p>在引入ES6语言的同时，引入了目前广泛使用和成熟的Airbnb语言规范，有现成的规</p>\n<p>范文档。引入eslint工具，保证大家代码的规范性。在编辑和“编译”阶段，项目中引入相关eslint组件，自动检查代码的风格是否符合规范。</p>\n<p>对不符合规范的代码，会给出错误提示，并不能执行代码。</p>\n<p>大家在学习Airbnb的规范的同时，对照ES5和ES6的写法，快速完成语言的切换。</p>\n<p>下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\"><span class=\"keyword\">const</span> len = items.length;</div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [];</div><div class=\"line\"><span class=\"keyword\">let</span> i;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">  itemsCopy[i] = items[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>\n<h3 id=\"CSS预处理器SASS\"><a href=\"#CSS预处理器SASS\" class=\"headerlink\" title=\"CSS预处理器SASS\"></a>CSS预处理器SASS</h3><p>样式预处理器SASS，为CSS带来了编程语言的能力，比如变量、函数和模块化。使用SASS能够很大程度上提高代码的复用度。</p>\n<p>JavaScript有eslint检查工具，对于SASS可以使用stylelint检查代码，</p>\n<p>遗憾的是社区开源的编辑器插件不是很完善，只找到了atom版本。</p>\n<h3 id=\"HTMl的规范化\"><a href=\"#HTMl的规范化\" class=\"headerlink\" title=\"HTMl的规范化\"></a>HTMl的规范化</h3><p>技术架构统一为Vue2.x，很遗憾没有找到Vue中HTML的规范化工具，后期会进行引入或研究开源。</p>\n<h2 id=\"组件化到模块化再到开源贡献\"><a href=\"#组件化到模块化再到开源贡献\" class=\"headerlink\" title=\"组件化到模块化再到开源贡献\"></a>组件化到模块化再到开源贡献</h2><p>Vue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。<br>每个产品都有自己的一套time-format模块，不同产品线，重复劳动太多。</p>\n<p>团队不仅仅需要组件化，我们需要将公共代码进行模块化，感谢Node社区。</p>\n<p>各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。</p>\n<p>希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。</p>\n<p>不止于业务，向前一步。</p>\n<p>在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。</p>\n<h2 id=\"源代码即文档\"><a href=\"#源代码即文档\" class=\"headerlink\" title=\"源代码即文档\"></a>源代码即文档</h2><p>设计了声明式的model层，从代码中直观的看到接口协议，地址和参数规则等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// define api</div><div class=\"line\">export const addInternalGroup = schema.post(&apos;/path/to/action&apos;, &#123;</div><div class=\"line\">  name: &#123; type: String, required: true &#125;,</div><div class=\"line\">  info: &#123; type: String, required: true &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// use api</div><div class=\"line\">addInternalGroup(&#123; name: &apos;xxx&apos;, info: &apos;xxx&apos; &#125;).then((json) =&gt; &#123;</div><div class=\"line\">  log(json);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>开源了apischema <a href=\"https://www.npmjs.com/package/apischema\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/apischema</a></p>\n<h2 id=\"从前端到大前端之路\"><a href=\"#从前端到大前端之路\" class=\"headerlink\" title=\"从前端到大前端之路\"></a>从前端到大前端之路</h2><p>工程师要竖立前端大局观，从不同的角度考虑技术方案。</p>\n<p>用前端的方案实现产品的灰度分流和配置。</p>\n<p>基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。</p>\n<p>后期会优先在分析线落地。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>在前端工程化方面还有很长的路要走，持续学习和进步。</p>\n<p>加油2017！</p>\n"},{"title":"渐进式全栈开发策略","date":"2017-06-16T03:18:25.000Z","_content":"\n渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。\n\n这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。\n\n最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。\n\n可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。\n\n原则上，在开发过程中应该尽量做到：\n1. 同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；\n2. 开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。\n3. 在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。\n\n\n前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：[语义化版本](http://semver.org/lang/zh-CN/)，[package.json规则](https://docs.npmjs.com/files/package.json)、[单元测试](https://mochajs.org/)、npm组件发布等等。\n\n但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。\n","source":"_posts/渐进式全栈开发策略.md","raw":"---\ntitle: 渐进式全栈开发策略\ndate: 2017-06-16 11:18:25\ntags: [全栈,Node]\n---\n\n渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。\n\n这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。\n\n最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。\n\n可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。\n\n原则上，在开发过程中应该尽量做到：\n1. 同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；\n2. 开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。\n3. 在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。\n\n\n前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：[语义化版本](http://semver.org/lang/zh-CN/)，[package.json规则](https://docs.npmjs.com/files/package.json)、[单元测试](https://mochajs.org/)、npm组件发布等等。\n\n但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。\n","slug":"渐进式全栈开发策略","published":1,"updated":"2017-06-22T10:08:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6hm1b4d0001ertx7thh81gt","content":"<p>渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。</p>\n<p>这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。</p>\n<p>最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。</p>\n<p>可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。</p>\n<p>原则上，在开发过程中应该尽量做到：</p>\n<ol>\n<li>同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；</li>\n<li>开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。</li>\n<li>在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。</li>\n</ol>\n<p>前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本</a>，<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a>、<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">单元测试</a>、npm组件发布等等。</p>\n<p>但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。</p>\n<p>这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。</p>\n<p>最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。</p>\n<p>可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。</p>\n<p>原则上，在开发过程中应该尽量做到：</p>\n<ol>\n<li>同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；</li>\n<li>开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。</li>\n<li>在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。</li>\n</ol>\n<p>前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本</a>，<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a>、<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">单元测试</a>、npm组件发布等等。</p>\n<p>但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj6hm1b460000ertxxfigt09t","tag_id":"cj6hm1b4g0002ertxrxz45mc1","_id":"cj6hm1b4p0007ertxm5b50yli"},{"post_id":"cj6hm1b460000ertxxfigt09t","tag_id":"cj6hm1b4m0003ertx651moei9","_id":"cj6hm1b4p0008ertxfczsx8a1"},{"post_id":"cj6hm1b460000ertxxfigt09t","tag_id":"cj6hm1b4n0004ertxeychnvgq","_id":"cj6hm1b4p000aertx98hwvdkf"},{"post_id":"cj6hm1b460000ertxxfigt09t","tag_id":"cj6hm1b4n0005ertxndl4qa3q","_id":"cj6hm1b4q000bertxlj5h3hvl"},{"post_id":"cj6hm1b4d0001ertx7thh81gt","tag_id":"cj6hm1b4o0006ertx3vmzrq95","_id":"cj6hm1b4q000certx98qmm66f"},{"post_id":"cj6hm1b4d0001ertx7thh81gt","tag_id":"cj6hm1b4p0009ertxr5sfi307","_id":"cj6hm1b4q000dertxufml26qq"}],"Tag":[{"name":"草稿","_id":"cj6hm1b4g0002ertxrxz45mc1"},{"name":"工程化","_id":"cj6hm1b4m0003ertx651moei9"},{"name":"git","_id":"cj6hm1b4n0004ertxeychnvgq"},{"name":"eslint","_id":"cj6hm1b4n0005ertxndl4qa3q"},{"name":"全栈","_id":"cj6hm1b4o0006ertx3vmzrq95"},{"name":"Node","_id":"cj6hm1b4p0009ertxr5sfi307"}]}}