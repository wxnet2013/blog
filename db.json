{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/Hacker/source/images/icon-heart.svg","path":"images/icon-heart.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/article.styl","path":"css/components/article.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/archive.styl","path":"css/components/archive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/base/normalize.css","path":"css/base/normalize.css","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/categories.styl","path":"css/components/categories.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/header.styl","path":"css/components/header.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/footer.styl","path":"css/components/footer.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/icon.styl","path":"css/components/icon.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/responsive.styl","path":"css/components/responsive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/layout.styl","path":"css/components/layout.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/pagination.styl","path":"css/components/pagination.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/syntax.styl","path":"css/components/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/tags.styl","path":"css/components/tags.styl","modified":1,"renderable":1}],"Cache":[{"_id":"themes/Hacker/.gitignore","hash":"803c06a7086b5817c03d2e8672da27bc56ba2bce","modified":1485843797000},{"_id":"source/CNAME","hash":"d3af5b9b062d55a5445af8908c3a1671e35639a1","modified":1497240939000},{"_id":"themes/Hacker/README.md","hash":"71077f7bdebc6e8d36f763e715ec2d55ddca4141","modified":1485843797000},{"_id":"themes/Hacker/README_zh-CN.md","hash":"d6c9200e96bb3633c3a84de169f91e6c34a5ea14","modified":1485843797000},{"_id":"themes/Hacker/LICENSE","hash":"3127907a7623734f830e8c69ccee03b693bf993e","modified":1485843797000},{"_id":"themes/Hacker/_config.yml","hash":"5d8cc859c48024451a316c50ab16ba58702b062d","modified":1485843797000},{"_id":"source/_posts/前端工程化实践.md","hash":"11a50637dc2c34887b21ecc0897d6d0710a54d62","modified":1502992480000},{"_id":"source/_posts/渐进式全栈开发策略.md","hash":"4dc1b0717dc45b403666bea02c2e7c4a611a3ee7","modified":1498126115000},{"_id":"themes/Hacker/languages/default.yml","hash":"ef90548952b1f9cc88dbe9daad882786212aec38","modified":1485843797000},{"_id":"themes/Hacker/languages/zh-CN.yml","hash":"18638177b944e0deb4a8c26a1c4a980901151132","modified":1485843797000},{"_id":"themes/Hacker/layout/categories.ejs","hash":"bfad4e7eade650c535f0194974e2646619657b8b","modified":1485843797000},{"_id":"themes/Hacker/layout/archive.ejs","hash":"2238cbe29009aafb16969d2c70dceb3f71772123","modified":1485843797000},{"_id":"themes/Hacker/layout/index.ejs","hash":"1d2c487a95d25e763b5f7e004194eb6ee6b18135","modified":1485843797000},{"_id":"themes/Hacker/layout/page.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1485843797000},{"_id":"themes/Hacker/layout/layout.ejs","hash":"341e77b5f07457e4ccd69634f511da05a5d89f18","modified":1485843797000},{"_id":"themes/Hacker/layout/post.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1485843797000},{"_id":"themes/Hacker/layout/tags.ejs","hash":"ee89e6a9c14bdb5e5e8cf975a558c780fe8dabff","modified":1485843797000},{"_id":"themes/Hacker/layout/components/comment.ejs","hash":"34b72f9819b5298be101f5c568cc7f2a52ab0f7d","modified":1485843797000},{"_id":"themes/Hacker/layout/components/archive.ejs","hash":"1f79ebaf52b8229cf5c58bb8325cf0177859a05c","modified":1485843797000},{"_id":"themes/Hacker/layout/components/article.ejs","hash":"5a08e05eb271589a2ed69fdd08516fa8457af3ed","modified":1485843797000},{"_id":"themes/Hacker/layout/components/categories.ejs","hash":"3665bf5d1c7181db22dc1c48d62ebf42757d8c27","modified":1485843797000},{"_id":"themes/Hacker/layout/components/footer.ejs","hash":"538795f4af3a98e824aefc4b68a1bcd210c091e9","modified":1485843797000},{"_id":"themes/Hacker/layout/components/googleanalytics.ejs","hash":"fa11251ace0fc61cbcffb74f32fbf5bdbb201ff2","modified":1485843797000},{"_id":"themes/Hacker/layout/components/head.ejs","hash":"10475fdfc513c9380f18d034e15b3b051c8e9269","modified":1485843797000},{"_id":"themes/Hacker/layout/components/header.ejs","hash":"929a8eafa278d49c2f41d3581e2608eca80d7856","modified":1485843797000},{"_id":"themes/Hacker/layout/components/pagination.ejs","hash":"4ab5e3b0239e467923a0f91c771bcc9ee7889cfe","modified":1485843797000},{"_id":"themes/Hacker/source/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1485843797000},{"_id":"themes/Hacker/source/css/style.styl","hash":"208e5f6d010e4e2c5590dae5e4fca8de592d3ef1","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/article.styl","hash":"e99f13c6744ddaa7f7bfcf0662e4dc6840fae8fa","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/archive.styl","hash":"de701a1dee6e870140565044a08c2c45cfcd4bc3","modified":1485843797000},{"_id":"themes/Hacker/source/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/categories.styl","hash":"c67e20d60351295cb178b568af42d430f4bcc3e6","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/header.styl","hash":"fa5e6d715d288a327406df78225284c70530cb98","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/footer.styl","hash":"80ef890252d31d3bbfe71740fdcfc54ae14cad8e","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/icon.styl","hash":"8da3ff5b6cd1609fdfe0c564d47391367abc8808","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/responsive.styl","hash":"053e7ec4c22845422440660b7e1d6b0dea5b4fbd","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/layout.styl","hash":"73c1688b95b20cd67669bc5567420f5be8448c9f","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/pagination.styl","hash":"c20a9920bb444c22b20e588f97eba4e03f09a439","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/syntax.styl","hash":"68b7deadab1ac13603eb5e812e1060db25227fd0","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/tags.styl","hash":"684cf4eb4b8671476365e955dceebf096cc0e6ed","modified":1485843797000},{"_id":"public/2017/06/16/渐进式全栈开发策略/index.html","hash":"d2480e5e95f77ad0f2085b413fa0389e1b225ef8","modified":1502992506177},{"_id":"public/archives/index.html","hash":"8f28423feea0c822f2adb31e0f361eb87572b09c","modified":1502992506235},{"_id":"public/archives/2017/index.html","hash":"01de55775645df9ef01e66538e3a1e9627e70c8e","modified":1502992506237},{"_id":"public/archives/2017/06/index.html","hash":"5c9edd23567352ca2b66938dbaff8c15f8c1bb81","modified":1502992506237},{"_id":"public/archives/2017/08/index.html","hash":"3de32d66e7ce53b93b7bc5a92da5837df11cd8ca","modified":1502992506238},{"_id":"public/index.html","hash":"f44904186f271f1cc8a4062ff0d435aa5f619f9a","modified":1502992506238},{"_id":"public/tags/全栈/index.html","hash":"adc23692cfc8b5739a7ad1bbbe090a0f0c6d8b16","modified":1502992506238},{"_id":"public/tags/Node/index.html","hash":"514e9788bc4b333ab5d6aaf162af5dd6a529e9f9","modified":1502992506238},{"_id":"public/2017/08/18/前端工程化实践/index.html","hash":"c7362a3f9fd4e9ade4e96c1f831c426095ae0d4e","modified":1502992506259},{"_id":"public/tags/草稿/index.html","hash":"efdd487ce30d1b368d3037632342a8a00e241dc5","modified":1502992506336},{"_id":"public/CNAME","hash":"d3af5b9b062d55a5445af8908c3a1671e35639a1","modified":1502992506337},{"_id":"public/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1502992506337},{"_id":"public/css/components/article.css","hash":"563b6fd19e1f5ba4787acd2ef2e1ee876e521cab","modified":1502992507341},{"_id":"public/css/components/archive.css","hash":"14902abf01556a3e23e03ac18c87fa7a5a39d89a","modified":1502992507341},{"_id":"public/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1502992507341},{"_id":"public/css/components/categories.css","hash":"f181d27640f1408f032c5386836c4c2322724f8d","modified":1502992507341},{"_id":"public/css/components/header.css","hash":"51f8a4c736f3b180a7c4c8f804d8060031df6a34","modified":1502992507341},{"_id":"public/css/components/footer.css","hash":"602def895fd52f288b6e93932284aa2e52b7fee0","modified":1502992507341},{"_id":"public/css/components/icon.css","hash":"cdaf1a152184ff7def760f14095e4a2fa16cd6bd","modified":1502992507342},{"_id":"public/css/components/responsive.css","hash":"216eb94fc69007de995fc8d382670ba00a9574e8","modified":1502992507342},{"_id":"public/css/components/layout.css","hash":"b8625c7b90a973f2e37897f346e6f80b779fd9ca","modified":1502992507342},{"_id":"public/css/components/pagination.css","hash":"2f3f9bb1bc6513d08865e7a2fb2160cc47d4a229","modified":1502992507342},{"_id":"public/css/components/syntax.css","hash":"00970bfdb168aa13622c829920907ca3416829f8","modified":1502992507342},{"_id":"public/css/components/tags.css","hash":"1566e94c23ae19dbfc7d2cf433e68242ed657dea","modified":1502992507342},{"_id":"public/css/style.css","hash":"48373889a036d403ca34bc085cabeb302e2a08ee","modified":1502992507342}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"前端工程化实践","date":"2017-08-17T16:00:00.000Z","_content":"\n# DTU前端工程化实践\n\n## 采用组件化的方式快速迭代产品\n\n前端组件是页面上可复用的UI单元，比如信息区块、页头、页尾、导航等。\n快速设计页面路由，整个产品包含哪些“栏目”，快速完成架构搭建。\n在工程正式开发之前，我们仔细研究了设计图，统计出整个产品包含哪些组件，哪些组件可复用程度更高。\n优先开发复用度高的组件，完成后快速拼装出产品页面。最后完成个性的组件等。\n\b前端开发的效率会依赖设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。\n\n(图片制作： 页面A --- 组件A --- 页面B)\n\n## git规范化\n### 规范化git工作流\n高效的开发团队，需要规范化的代码管理流程做保证，直接沿用了成熟的开发流程。\n每日集成的开发策略，在产品开发阶段，每位工程师在自己的开发分支下快速开发，每天下午定时，由组长将代码集成到daily分支。在集成的过程中，进行CodeReview，检查代码规范和逻辑的部分。集成后执行Jenkins的构建过程。\n\n产品上线后，进入快速迭代阶段，工程师的开发分支转换为功能分支。\n每天完成计划中功能的部分，集成到daily分支。\n\n每天的目标明确，成果可见，每天都很有成就感。\n\n（图片：git工作流图）\n\n### git提交规范\n怎样评价一次好的代码提交。一次代码提交应该做到原子性，一次提交完成一个bug的修改，一个功能的文档，一次重构等。好的代码提交说明，应该完全匹配修改的内容。提交说明，最好能够包含对修改的部分、类型给出明确的说明。\n\n\n（gitlab截图：）\n\n> fix(service):服务编辑时没有去掉可见性字段校验\n\n团队直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有配套的工具。\n\n（工具图片）\n```\n1、feat：新功能（feature）\n2、fix：修补bug\n3、docs：文档（documentation）\n4、style： 格式（不影响代码运行的变动）\n5、refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n6、test：增加测试\n7、chore：构建过程或辅助工具的变动\n```\n格式化的Commit message，有几个好处。\n\n1、提供更多的历史信息，方便代码CodeReview。\n2、可以过滤commit，快速查找信息。\n3、还可以由提交说明生成产品的changelog。\n（Jenkins截图）\n\n## 代码规范化\n组建一直规范化的前端团队，是我转型技术管理的理想，目标很简单：保证产品代码完全是由一个人写的，代码和注释风格的统一。\n\n### JavaScript的语言升级和规范化\n循序渐进的由ES5升级到ES6，比如禁止使用var声明变量，使用let或const替换。\n对于函数的声明，鼓励去掉function关键字和更多的使用箭头函数，使用函数的默认值；\n用模版字符串替换掉之前的字符串拼接；\n\n逐渐深入使用ES6的更多的特性。\n引入Airbnb的语言规范，并使用eslint在编辑阶段和“编译”阶段检查代码的风格是否符合规范。对不符合规范的代码，会给出错误提示，并不能执行代码。\n\n大家在学习Airbnb的规范的同时，对照ES5和ES6的写法，快速完成语言的切换。\n\n下面的代码，实现数据的复制，可以发现ES6代码会更简洁高效。\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n### CSS预处理器SASS\n样式预处理器SASS，为CSS带来了编程语言的能力，比如变量、函数和模块化。使用SASS能够很大程度上提高代码的复用度。\n\nJavaScript有eslint检查工具，对于SASS可以使用stylelint检查代码，\n\n遗憾的是社区开源的编辑器插件不是很完善，只找到了atom版本。\n\n### HTMl的规范化\n技术架构统一为Vue2.x，很遗憾没有找到Vue中HTML的规范化工具，后期会进行引入或研究开源。\n\n## 从组件化到模块化，从引用开源到开源贡献\nVue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。\n每个产品都有自己的time-format，重复劳动太多，不仅仅需要组件化，我们需要模块化！\n各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。\n希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。\n\n不止于业务，向前一步。在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。\n\n从制度到习惯。\n\n## 源代码即文档\n设计了声明式的model层，从代码中直观的看到接口协议，地址和参数规则等。\n```\n// define api\nexport const addInternalGroup = schema.post('/path/to/action', {\n  name: { type: String, required: true },\n  info: { type: String, required: true },\n});\n\n// use api\naddInternalGroup({ name: 'xxx', info: 'xxx' }).then((json) => {\n  log(json);  \n});\n```\n开源了apischema https://www.npmjs.com/package/apischema\n\n## 从前端到大前端\n\n工程师要竖立前端大局观，从不同的角度考虑技术方案。\n\n用前端的方案实现产品的灰度分流和配置。\n\n基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。\n\n后期会优先在分析线落地。\n\n## 最后\n在前端工程化方面还有很长的路要走，持续学习和进步。\n\n加油2017！\n","source":"_posts/前端工程化实践.md","raw":"---\ntitle: 前端工程化实践\ndate: 2017-08-18 00:00\ntags: [全栈,Node,草稿]\n---\n\n# DTU前端工程化实践\n\n## 采用组件化的方式快速迭代产品\n\n前端组件是页面上可复用的UI单元，比如信息区块、页头、页尾、导航等。\n快速设计页面路由，整个产品包含哪些“栏目”，快速完成架构搭建。\n在工程正式开发之前，我们仔细研究了设计图，统计出整个产品包含哪些组件，哪些组件可复用程度更高。\n优先开发复用度高的组件，完成后快速拼装出产品页面。最后完成个性的组件等。\n\b前端开发的效率会依赖设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。\n\n(图片制作： 页面A --- 组件A --- 页面B)\n\n## git规范化\n### 规范化git工作流\n高效的开发团队，需要规范化的代码管理流程做保证，直接沿用了成熟的开发流程。\n每日集成的开发策略，在产品开发阶段，每位工程师在自己的开发分支下快速开发，每天下午定时，由组长将代码集成到daily分支。在集成的过程中，进行CodeReview，检查代码规范和逻辑的部分。集成后执行Jenkins的构建过程。\n\n产品上线后，进入快速迭代阶段，工程师的开发分支转换为功能分支。\n每天完成计划中功能的部分，集成到daily分支。\n\n每天的目标明确，成果可见，每天都很有成就感。\n\n（图片：git工作流图）\n\n### git提交规范\n怎样评价一次好的代码提交。一次代码提交应该做到原子性，一次提交完成一个bug的修改，一个功能的文档，一次重构等。好的代码提交说明，应该完全匹配修改的内容。提交说明，最好能够包含对修改的部分、类型给出明确的说明。\n\n\n（gitlab截图：）\n\n> fix(service):服务编辑时没有去掉可见性字段校验\n\n团队直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有配套的工具。\n\n（工具图片）\n```\n1、feat：新功能（feature）\n2、fix：修补bug\n3、docs：文档（documentation）\n4、style： 格式（不影响代码运行的变动）\n5、refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n6、test：增加测试\n7、chore：构建过程或辅助工具的变动\n```\n格式化的Commit message，有几个好处。\n\n1、提供更多的历史信息，方便代码CodeReview。\n2、可以过滤commit，快速查找信息。\n3、还可以由提交说明生成产品的changelog。\n（Jenkins截图）\n\n## 代码规范化\n组建一直规范化的前端团队，是我转型技术管理的理想，目标很简单：保证产品代码完全是由一个人写的，代码和注释风格的统一。\n\n### JavaScript的语言升级和规范化\n循序渐进的由ES5升级到ES6，比如禁止使用var声明变量，使用let或const替换。\n对于函数的声明，鼓励去掉function关键字和更多的使用箭头函数，使用函数的默认值；\n用模版字符串替换掉之前的字符串拼接；\n\n逐渐深入使用ES6的更多的特性。\n引入Airbnb的语言规范，并使用eslint在编辑阶段和“编译”阶段检查代码的风格是否符合规范。对不符合规范的代码，会给出错误提示，并不能执行代码。\n\n大家在学习Airbnb的规范的同时，对照ES5和ES6的写法，快速完成语言的切换。\n\n下面的代码，实现数据的复制，可以发现ES6代码会更简洁高效。\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n### CSS预处理器SASS\n样式预处理器SASS，为CSS带来了编程语言的能力，比如变量、函数和模块化。使用SASS能够很大程度上提高代码的复用度。\n\nJavaScript有eslint检查工具，对于SASS可以使用stylelint检查代码，\n\n遗憾的是社区开源的编辑器插件不是很完善，只找到了atom版本。\n\n### HTMl的规范化\n技术架构统一为Vue2.x，很遗憾没有找到Vue中HTML的规范化工具，后期会进行引入或研究开源。\n\n## 从组件化到模块化，从引用开源到开源贡献\nVue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。\n每个产品都有自己的time-format，重复劳动太多，不仅仅需要组件化，我们需要模块化！\n各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。\n希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。\n\n不止于业务，向前一步。在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。\n\n从制度到习惯。\n\n## 源代码即文档\n设计了声明式的model层，从代码中直观的看到接口协议，地址和参数规则等。\n```\n// define api\nexport const addInternalGroup = schema.post('/path/to/action', {\n  name: { type: String, required: true },\n  info: { type: String, required: true },\n});\n\n// use api\naddInternalGroup({ name: 'xxx', info: 'xxx' }).then((json) => {\n  log(json);  \n});\n```\n开源了apischema https://www.npmjs.com/package/apischema\n\n## 从前端到大前端\n\n工程师要竖立前端大局观，从不同的角度考虑技术方案。\n\n用前端的方案实现产品的灰度分流和配置。\n\n基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。\n\n后期会优先在分析线落地。\n\n## 最后\n在前端工程化方面还有很长的路要走，持续学习和进步。\n\n加油2017！\n","slug":"前端工程化实践","published":1,"updated":"2017-08-17T17:54:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6gqxjcr0000bptxpy9fxs3h","content":"<h1 id=\"DTU前端工程化实践\"><a href=\"#DTU前端工程化实践\" class=\"headerlink\" title=\"DTU前端工程化实践\"></a>DTU前端工程化实践</h1><h2 id=\"采用组件化的方式快速迭代产品\"><a href=\"#采用组件化的方式快速迭代产品\" class=\"headerlink\" title=\"采用组件化的方式快速迭代产品\"></a>采用组件化的方式快速迭代产品</h2><p>前端组件是页面上可复用的UI单元，比如信息区块、页头、页尾、导航等。<br>快速设计页面路由，整个产品包含哪些“栏目”，快速完成架构搭建。<br>在工程正式开发之前，我们仔细研究了设计图，统计出整个产品包含哪些组件，哪些组件可复用程度更高。<br>优先开发复用度高的组件，完成后快速拼装出产品页面。最后完成个性的组件等。<br>\b前端开发的效率会依赖设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。</p>\n<p>(图片制作： 页面A — 组件A — 页面B)</p>\n<h2 id=\"git规范化\"><a href=\"#git规范化\" class=\"headerlink\" title=\"git规范化\"></a>git规范化</h2><h3 id=\"规范化git工作流\"><a href=\"#规范化git工作流\" class=\"headerlink\" title=\"规范化git工作流\"></a>规范化git工作流</h3><p>高效的开发团队，需要规范化的代码管理流程做保证，直接沿用了成熟的开发流程。<br>每日集成的开发策略，在产品开发阶段，每位工程师在自己的开发分支下快速开发，每天下午定时，由组长将代码集成到daily分支。在集成的过程中，进行CodeReview，检查代码规范和逻辑的部分。集成后执行Jenkins的构建过程。</p>\n<p>产品上线后，进入快速迭代阶段，工程师的开发分支转换为功能分支。<br>每天完成计划中功能的部分，集成到daily分支。</p>\n<p>每天的目标明确，成果可见，每天都很有成就感。</p>\n<p>（图片：git工作流图）</p>\n<h3 id=\"git提交规范\"><a href=\"#git提交规范\" class=\"headerlink\" title=\"git提交规范\"></a>git提交规范</h3><p>怎样评价一次好的代码提交。一次代码提交应该做到原子性，一次提交完成一个bug的修改，一个功能的文档，一次重构等。好的代码提交说明，应该完全匹配修改的内容。提交说明，最好能够包含对修改的部分、类型给出明确的说明。</p>\n<p>（gitlab截图：）</p>\n<blockquote>\n<p>fix(service):服务编辑时没有去掉可见性字段校验</p>\n</blockquote>\n<p>团队直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有配套的工具。</p>\n<p>（工具图片）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">1、feat：新功能（feature）</div><div class=\"line\">2、fix：修补bug</div><div class=\"line\">3、docs：文档（documentation）</div><div class=\"line\">4、style： 格式（不影响代码运行的变动）</div><div class=\"line\">5、refactor：重构（即不是新增功能，也不是修改bug的代码变动）</div><div class=\"line\">6、test：增加测试</div><div class=\"line\">7、chore：构建过程或辅助工具的变动</div></pre></td></tr></table></figure></p>\n<p>格式化的Commit message，有几个好处。</p>\n<p>1、提供更多的历史信息，方便代码CodeReview。<br>2、可以过滤commit，快速查找信息。<br>3、还可以由提交说明生成产品的changelog。<br>（Jenkins截图）</p>\n<h2 id=\"代码规范化\"><a href=\"#代码规范化\" class=\"headerlink\" title=\"代码规范化\"></a>代码规范化</h2><p>组建一直规范化的前端团队，是我转型技术管理的理想，目标很简单：保证产品代码完全是由一个人写的，代码和注释风格的统一。</p>\n<h3 id=\"JavaScript的语言升级和规范化\"><a href=\"#JavaScript的语言升级和规范化\" class=\"headerlink\" title=\"JavaScript的语言升级和规范化\"></a>JavaScript的语言升级和规范化</h3><p>循序渐进的由ES5升级到ES6，比如禁止使用var声明变量，使用let或const替换。<br>对于函数的声明，鼓励去掉function关键字和更多的使用箭头函数，使用函数的默认值；<br>用模版字符串替换掉之前的字符串拼接；</p>\n<p>逐渐深入使用ES6的更多的特性。<br>引入Airbnb的语言规范，并使用eslint在编辑阶段和“编译”阶段检查代码的风格是否符合规范。对不符合规范的代码，会给出错误提示，并不能执行代码。</p>\n<p>大家在学习Airbnb的规范的同时，对照ES5和ES6的写法，快速完成语言的切换。</p>\n<p>下面的代码，实现数据的复制，可以发现ES6代码会更简洁高效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\"><span class=\"keyword\">const</span> len = items.length;</div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [];</div><div class=\"line\"><span class=\"keyword\">let</span> i;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">  itemsCopy[i] = items[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>\n<h3 id=\"CSS预处理器SASS\"><a href=\"#CSS预处理器SASS\" class=\"headerlink\" title=\"CSS预处理器SASS\"></a>CSS预处理器SASS</h3><p>样式预处理器SASS，为CSS带来了编程语言的能力，比如变量、函数和模块化。使用SASS能够很大程度上提高代码的复用度。</p>\n<p>JavaScript有eslint检查工具，对于SASS可以使用stylelint检查代码，</p>\n<p>遗憾的是社区开源的编辑器插件不是很完善，只找到了atom版本。</p>\n<h3 id=\"HTMl的规范化\"><a href=\"#HTMl的规范化\" class=\"headerlink\" title=\"HTMl的规范化\"></a>HTMl的规范化</h3><p>技术架构统一为Vue2.x，很遗憾没有找到Vue中HTML的规范化工具，后期会进行引入或研究开源。</p>\n<h2 id=\"从组件化到模块化，从引用开源到开源贡献\"><a href=\"#从组件化到模块化，从引用开源到开源贡献\" class=\"headerlink\" title=\"从组件化到模块化，从引用开源到开源贡献\"></a>从组件化到模块化，从引用开源到开源贡献</h2><p>Vue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。<br>每个产品都有自己的time-format，重复劳动太多，不仅仅需要组件化，我们需要模块化！<br>各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。<br>希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。</p>\n<p>不止于业务，向前一步。在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。</p>\n<p>从制度到习惯。</p>\n<h2 id=\"源代码即文档\"><a href=\"#源代码即文档\" class=\"headerlink\" title=\"源代码即文档\"></a>源代码即文档</h2><p>设计了声明式的model层，从代码中直观的看到接口协议，地址和参数规则等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// define api</div><div class=\"line\">export const addInternalGroup = schema.post(&apos;/path/to/action&apos;, &#123;</div><div class=\"line\">  name: &#123; type: String, required: true &#125;,</div><div class=\"line\">  info: &#123; type: String, required: true &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// use api</div><div class=\"line\">addInternalGroup(&#123; name: &apos;xxx&apos;, info: &apos;xxx&apos; &#125;).then((json) =&gt; &#123;</div><div class=\"line\">  log(json);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>开源了apischema <a href=\"https://www.npmjs.com/package/apischema\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/apischema</a></p>\n<h2 id=\"从前端到大前端\"><a href=\"#从前端到大前端\" class=\"headerlink\" title=\"从前端到大前端\"></a>从前端到大前端</h2><p>工程师要竖立前端大局观，从不同的角度考虑技术方案。</p>\n<p>用前端的方案实现产品的灰度分流和配置。</p>\n<p>基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。</p>\n<p>后期会优先在分析线落地。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>在前端工程化方面还有很长的路要走，持续学习和进步。</p>\n<p>加油2017！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"DTU前端工程化实践\"><a href=\"#DTU前端工程化实践\" class=\"headerlink\" title=\"DTU前端工程化实践\"></a>DTU前端工程化实践</h1><h2 id=\"采用组件化的方式快速迭代产品\"><a href=\"#采用组件化的方式快速迭代产品\" class=\"headerlink\" title=\"采用组件化的方式快速迭代产品\"></a>采用组件化的方式快速迭代产品</h2><p>前端组件是页面上可复用的UI单元，比如信息区块、页头、页尾、导航等。<br>快速设计页面路由，整个产品包含哪些“栏目”，快速完成架构搭建。<br>在工程正式开发之前，我们仔细研究了设计图，统计出整个产品包含哪些组件，哪些组件可复用程度更高。<br>优先开发复用度高的组件，完成后快速拼装出产品页面。最后完成个性的组件等。<br>\b前端开发的效率会依赖设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。</p>\n<p>(图片制作： 页面A — 组件A — 页面B)</p>\n<h2 id=\"git规范化\"><a href=\"#git规范化\" class=\"headerlink\" title=\"git规范化\"></a>git规范化</h2><h3 id=\"规范化git工作流\"><a href=\"#规范化git工作流\" class=\"headerlink\" title=\"规范化git工作流\"></a>规范化git工作流</h3><p>高效的开发团队，需要规范化的代码管理流程做保证，直接沿用了成熟的开发流程。<br>每日集成的开发策略，在产品开发阶段，每位工程师在自己的开发分支下快速开发，每天下午定时，由组长将代码集成到daily分支。在集成的过程中，进行CodeReview，检查代码规范和逻辑的部分。集成后执行Jenkins的构建过程。</p>\n<p>产品上线后，进入快速迭代阶段，工程师的开发分支转换为功能分支。<br>每天完成计划中功能的部分，集成到daily分支。</p>\n<p>每天的目标明确，成果可见，每天都很有成就感。</p>\n<p>（图片：git工作流图）</p>\n<h3 id=\"git提交规范\"><a href=\"#git提交规范\" class=\"headerlink\" title=\"git提交规范\"></a>git提交规范</h3><p>怎样评价一次好的代码提交。一次代码提交应该做到原子性，一次提交完成一个bug的修改，一个功能的文档，一次重构等。好的代码提交说明，应该完全匹配修改的内容。提交说明，最好能够包含对修改的部分、类型给出明确的说明。</p>\n<p>（gitlab截图：）</p>\n<blockquote>\n<p>fix(service):服务编辑时没有去掉可见性字段校验</p>\n</blockquote>\n<p>团队直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有配套的工具。</p>\n<p>（工具图片）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">1、feat：新功能（feature）</div><div class=\"line\">2、fix：修补bug</div><div class=\"line\">3、docs：文档（documentation）</div><div class=\"line\">4、style： 格式（不影响代码运行的变动）</div><div class=\"line\">5、refactor：重构（即不是新增功能，也不是修改bug的代码变动）</div><div class=\"line\">6、test：增加测试</div><div class=\"line\">7、chore：构建过程或辅助工具的变动</div></pre></td></tr></table></figure></p>\n<p>格式化的Commit message，有几个好处。</p>\n<p>1、提供更多的历史信息，方便代码CodeReview。<br>2、可以过滤commit，快速查找信息。<br>3、还可以由提交说明生成产品的changelog。<br>（Jenkins截图）</p>\n<h2 id=\"代码规范化\"><a href=\"#代码规范化\" class=\"headerlink\" title=\"代码规范化\"></a>代码规范化</h2><p>组建一直规范化的前端团队，是我转型技术管理的理想，目标很简单：保证产品代码完全是由一个人写的，代码和注释风格的统一。</p>\n<h3 id=\"JavaScript的语言升级和规范化\"><a href=\"#JavaScript的语言升级和规范化\" class=\"headerlink\" title=\"JavaScript的语言升级和规范化\"></a>JavaScript的语言升级和规范化</h3><p>循序渐进的由ES5升级到ES6，比如禁止使用var声明变量，使用let或const替换。<br>对于函数的声明，鼓励去掉function关键字和更多的使用箭头函数，使用函数的默认值；<br>用模版字符串替换掉之前的字符串拼接；</p>\n<p>逐渐深入使用ES6的更多的特性。<br>引入Airbnb的语言规范，并使用eslint在编辑阶段和“编译”阶段检查代码的风格是否符合规范。对不符合规范的代码，会给出错误提示，并不能执行代码。</p>\n<p>大家在学习Airbnb的规范的同时，对照ES5和ES6的写法，快速完成语言的切换。</p>\n<p>下面的代码，实现数据的复制，可以发现ES6代码会更简洁高效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\"><span class=\"keyword\">const</span> len = items.length;</div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [];</div><div class=\"line\"><span class=\"keyword\">let</span> i;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">  itemsCopy[i] = items[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>\n<h3 id=\"CSS预处理器SASS\"><a href=\"#CSS预处理器SASS\" class=\"headerlink\" title=\"CSS预处理器SASS\"></a>CSS预处理器SASS</h3><p>样式预处理器SASS，为CSS带来了编程语言的能力，比如变量、函数和模块化。使用SASS能够很大程度上提高代码的复用度。</p>\n<p>JavaScript有eslint检查工具，对于SASS可以使用stylelint检查代码，</p>\n<p>遗憾的是社区开源的编辑器插件不是很完善，只找到了atom版本。</p>\n<h3 id=\"HTMl的规范化\"><a href=\"#HTMl的规范化\" class=\"headerlink\" title=\"HTMl的规范化\"></a>HTMl的规范化</h3><p>技术架构统一为Vue2.x，很遗憾没有找到Vue中HTML的规范化工具，后期会进行引入或研究开源。</p>\n<h2 id=\"从组件化到模块化，从引用开源到开源贡献\"><a href=\"#从组件化到模块化，从引用开源到开源贡献\" class=\"headerlink\" title=\"从组件化到模块化，从引用开源到开源贡献\"></a>从组件化到模块化，从引用开源到开源贡献</h2><p>Vue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。<br>每个产品都有自己的time-format，重复劳动太多，不仅仅需要组件化，我们需要模块化！<br>各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。<br>希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。</p>\n<p>不止于业务，向前一步。在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。</p>\n<p>从制度到习惯。</p>\n<h2 id=\"源代码即文档\"><a href=\"#源代码即文档\" class=\"headerlink\" title=\"源代码即文档\"></a>源代码即文档</h2><p>设计了声明式的model层，从代码中直观的看到接口协议，地址和参数规则等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// define api</div><div class=\"line\">export const addInternalGroup = schema.post(&apos;/path/to/action&apos;, &#123;</div><div class=\"line\">  name: &#123; type: String, required: true &#125;,</div><div class=\"line\">  info: &#123; type: String, required: true &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// use api</div><div class=\"line\">addInternalGroup(&#123; name: &apos;xxx&apos;, info: &apos;xxx&apos; &#125;).then((json) =&gt; &#123;</div><div class=\"line\">  log(json);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>开源了apischema <a href=\"https://www.npmjs.com/package/apischema\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/apischema</a></p>\n<h2 id=\"从前端到大前端\"><a href=\"#从前端到大前端\" class=\"headerlink\" title=\"从前端到大前端\"></a>从前端到大前端</h2><p>工程师要竖立前端大局观，从不同的角度考虑技术方案。</p>\n<p>用前端的方案实现产品的灰度分流和配置。</p>\n<p>基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。</p>\n<p>后期会优先在分析线落地。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>在前端工程化方面还有很长的路要走，持续学习和进步。</p>\n<p>加油2017！</p>\n"},{"title":"渐进式全栈开发策略","date":"2017-06-16T03:18:25.000Z","_content":"\n渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。\n\n这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。\n\n最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。\n\n可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。\n\n原则上，在开发过程中应该尽量做到：\n1. 同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；\n2. 开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。\n3. 在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。\n\n\n前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：[语义化版本](http://semver.org/lang/zh-CN/)，[package.json规则](https://docs.npmjs.com/files/package.json)、[单元测试](https://mochajs.org/)、npm组件发布等等。\n\n但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。\n","source":"_posts/渐进式全栈开发策略.md","raw":"---\ntitle: 渐进式全栈开发策略\ndate: 2017-06-16 11:18:25\ntags: [全栈,Node]\n---\n\n渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。\n\n这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。\n\n最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。\n\n可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。\n\n原则上，在开发过程中应该尽量做到：\n1. 同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；\n2. 开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。\n3. 在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。\n\n\n前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：[语义化版本](http://semver.org/lang/zh-CN/)，[package.json规则](https://docs.npmjs.com/files/package.json)、[单元测试](https://mochajs.org/)、npm组件发布等等。\n\n但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。\n","slug":"渐进式全栈开发策略","published":1,"updated":"2017-06-22T10:08:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6gqxjd00001bptxu5ihqef2","content":"<p>渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。</p>\n<p>这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。</p>\n<p>最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。</p>\n<p>可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。</p>\n<p>原则上，在开发过程中应该尽量做到：</p>\n<ol>\n<li>同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；</li>\n<li>开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。</li>\n<li>在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。</li>\n</ol>\n<p>前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本</a>，<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a>、<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">单元测试</a>、npm组件发布等等。</p>\n<p>但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。</p>\n<p>这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。</p>\n<p>最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。</p>\n<p>可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。</p>\n<p>原则上，在开发过程中应该尽量做到：</p>\n<ol>\n<li>同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；</li>\n<li>开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。</li>\n<li>在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。</li>\n</ol>\n<p>前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本</a>，<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a>、<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">单元测试</a>、npm组件发布等等。</p>\n<p>但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj6gqxjcr0000bptxpy9fxs3h","tag_id":"cj6gqxjd80002bptxigzzazn0","_id":"cj6gqxjds0006bptxfd6bmznx"},{"post_id":"cj6gqxjcr0000bptxpy9fxs3h","tag_id":"cj6gqxjdg0003bptx4z63wpxp","_id":"cj6gqxjds0007bptxa2ggmwp9"},{"post_id":"cj6gqxjcr0000bptxpy9fxs3h","tag_id":"cj6gqxjdk0004bptxgj3bcgvz","_id":"cj6gqxjdu0009bptx8ib1c2yd"},{"post_id":"cj6gqxjd00001bptxu5ihqef2","tag_id":"cj6gqxjd80002bptxigzzazn0","_id":"cj6gqxjdx000abptxjwc056i6"},{"post_id":"cj6gqxjd00001bptxu5ihqef2","tag_id":"cj6gqxjdg0003bptx4z63wpxp","_id":"cj6gqxjdy000bbptxo72jjfiz"}],"Tag":[{"name":"全栈","_id":"cj6gqxjd80002bptxigzzazn0"},{"name":"Node","_id":"cj6gqxjdg0003bptx4z63wpxp"},{"name":"草稿","_id":"cj6gqxjdk0004bptxgj3bcgvz"}]}}