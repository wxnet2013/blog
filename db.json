{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/Hacker/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/images/icon-heart.svg","path":"images/icon-heart.svg","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/base/normalize.css","path":"css/base/normalize.css","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/article.styl","path":"css/components/article.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/categories.styl","path":"css/components/categories.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/archive.styl","path":"css/components/archive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/footer.styl","path":"css/components/footer.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/header.styl","path":"css/components/header.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/layout.styl","path":"css/components/layout.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/icon.styl","path":"css/components/icon.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/pagination.styl","path":"css/components/pagination.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/responsive.styl","path":"css/components/responsive.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/syntax.styl","path":"css/components/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Hacker/source/css/components/tags.styl","path":"css/components/tags.styl","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"d3af5b9b062d55a5445af8908c3a1671e35639a1","modified":1497240939000},{"_id":"themes/Hacker/.gitignore","hash":"803c06a7086b5817c03d2e8672da27bc56ba2bce","modified":1485843797000},{"_id":"themes/Hacker/LICENSE","hash":"3127907a7623734f830e8c69ccee03b693bf993e","modified":1485843797000},{"_id":"themes/Hacker/README.md","hash":"71077f7bdebc6e8d36f763e715ec2d55ddca4141","modified":1485843797000},{"_id":"themes/Hacker/README_zh-CN.md","hash":"d6c9200e96bb3633c3a84de169f91e6c34a5ea14","modified":1485843797000},{"_id":"themes/Hacker/_config.yml","hash":"5d8cc859c48024451a316c50ab16ba58702b062d","modified":1485843797000},{"_id":"source/_posts/前端工程化实践.md","hash":"f243c78607ef53811f3dedf04c6e7b02c2eb4c53","modified":1503080752000},{"_id":"source/_posts/bd_logo1.png","hash":"011387db777ff33fa46481bb4ebabbac796240a9","modified":1503080679000},{"_id":"source/_posts/渐进式全栈开发策略.md","hash":"4dc1b0717dc45b403666bea02c2e7c4a611a3ee7","modified":1498126115000},{"_id":"themes/Hacker/layout/archive.ejs","hash":"2238cbe29009aafb16969d2c70dceb3f71772123","modified":1485843797000},{"_id":"themes/Hacker/layout/categories.ejs","hash":"bfad4e7eade650c535f0194974e2646619657b8b","modified":1485843797000},{"_id":"themes/Hacker/layout/index.ejs","hash":"1d2c487a95d25e763b5f7e004194eb6ee6b18135","modified":1485843797000},{"_id":"themes/Hacker/layout/layout.ejs","hash":"341e77b5f07457e4ccd69634f511da05a5d89f18","modified":1485843797000},{"_id":"themes/Hacker/layout/page.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1485843797000},{"_id":"themes/Hacker/layout/post.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1485843797000},{"_id":"themes/Hacker/languages/default.yml","hash":"ef90548952b1f9cc88dbe9daad882786212aec38","modified":1485843797000},{"_id":"themes/Hacker/languages/zh-CN.yml","hash":"18638177b944e0deb4a8c26a1c4a980901151132","modified":1485843797000},{"_id":"themes/Hacker/layout/tags.ejs","hash":"ee89e6a9c14bdb5e5e8cf975a558c780fe8dabff","modified":1485843797000},{"_id":"themes/Hacker/layout/components/archive.ejs","hash":"1f79ebaf52b8229cf5c58bb8325cf0177859a05c","modified":1485843797000},{"_id":"themes/Hacker/layout/components/categories.ejs","hash":"3665bf5d1c7181db22dc1c48d62ebf42757d8c27","modified":1485843797000},{"_id":"themes/Hacker/layout/components/comment.ejs","hash":"34b72f9819b5298be101f5c568cc7f2a52ab0f7d","modified":1485843797000},{"_id":"themes/Hacker/layout/components/article.ejs","hash":"5a08e05eb271589a2ed69fdd08516fa8457af3ed","modified":1485843797000},{"_id":"themes/Hacker/layout/components/footer.ejs","hash":"538795f4af3a98e824aefc4b68a1bcd210c091e9","modified":1485843797000},{"_id":"themes/Hacker/layout/components/googleanalytics.ejs","hash":"fa11251ace0fc61cbcffb74f32fbf5bdbb201ff2","modified":1485843797000},{"_id":"themes/Hacker/layout/components/head.ejs","hash":"10475fdfc513c9380f18d034e15b3b051c8e9269","modified":1485843797000},{"_id":"themes/Hacker/layout/components/header.ejs","hash":"929a8eafa278d49c2f41d3581e2608eca80d7856","modified":1485843797000},{"_id":"themes/Hacker/layout/components/pagination.ejs","hash":"4ab5e3b0239e467923a0f91c771bcc9ee7889cfe","modified":1485843797000},{"_id":"themes/Hacker/source/css/style.styl","hash":"208e5f6d010e4e2c5590dae5e4fca8de592d3ef1","modified":1485843797000},{"_id":"themes/Hacker/source/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1485843797000},{"_id":"themes/Hacker/source/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/article.styl","hash":"e99f13c6744ddaa7f7bfcf0662e4dc6840fae8fa","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/categories.styl","hash":"c67e20d60351295cb178b568af42d430f4bcc3e6","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/archive.styl","hash":"de701a1dee6e870140565044a08c2c45cfcd4bc3","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/footer.styl","hash":"80ef890252d31d3bbfe71740fdcfc54ae14cad8e","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/header.styl","hash":"fa5e6d715d288a327406df78225284c70530cb98","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/layout.styl","hash":"73c1688b95b20cd67669bc5567420f5be8448c9f","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/icon.styl","hash":"8da3ff5b6cd1609fdfe0c564d47391367abc8808","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/pagination.styl","hash":"c20a9920bb444c22b20e588f97eba4e03f09a439","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/responsive.styl","hash":"053e7ec4c22845422440660b7e1d6b0dea5b4fbd","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/syntax.styl","hash":"68b7deadab1ac13603eb5e812e1060db25227fd0","modified":1485843797000},{"_id":"themes/Hacker/source/css/components/tags.styl","hash":"684cf4eb4b8671476365e955dceebf096cc0e6ed","modified":1485843797000},{"_id":"public/2017/06/16/渐进式全栈开发策略/index.html","hash":"d2480e5e95f77ad0f2085b413fa0389e1b225ef8","modified":1503080844663},{"_id":"public/archives/index.html","hash":"8f28423feea0c822f2adb31e0f361eb87572b09c","modified":1503080844664},{"_id":"public/archives/2017/index.html","hash":"01de55775645df9ef01e66538e3a1e9627e70c8e","modified":1503080844664},{"_id":"public/archives/2017/06/index.html","hash":"5c9edd23567352ca2b66938dbaff8c15f8c1bb81","modified":1503080844664},{"_id":"public/archives/2017/08/index.html","hash":"3de32d66e7ce53b93b7bc5a92da5837df11cd8ca","modified":1503080844664},{"_id":"public/tags/工程化/index.html","hash":"2bd9fc03ea3b95e513caabac66d96821a17d3916","modified":1503080844664},{"_id":"public/tags/git/index.html","hash":"5c2b2204ae06051e7a856c2c139fd2b451892607","modified":1503080844664},{"_id":"public/tags/eslint/index.html","hash":"bb78cc6a9f924906451293171e3c76ab83ea11f7","modified":1503080844664},{"_id":"public/tags/全栈/index.html","hash":"f85c553d641d299b58d7f22275cbc0a7716a67db","modified":1503080844664},{"_id":"public/tags/Node/index.html","hash":"03e8c6c87b8070471f2e9fb899bb35f20a2bca28","modified":1503080844664},{"_id":"public/2017/08/18/前端工程化实践/index.html","hash":"d187a7f4cd45e68f4468e39425d6b9ba26dc7e62","modified":1503080844665},{"_id":"public/index.html","hash":"f323003e5592d2c0a9af5a953d2f487f9f22ad23","modified":1503080844665},{"_id":"public/tags/修订二/index.html","hash":"b7585a36b1670d44a104af8acf3c4ab5adec093a","modified":1503080844686},{"_id":"public/CNAME","hash":"d3af5b9b062d55a5445af8908c3a1671e35639a1","modified":1503080844686},{"_id":"public/images/icon-heart.svg","hash":"ec483e96c88eea013fd8ac71a34a875107397f43","modified":1503080844686},{"_id":"public/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1503080845079},{"_id":"public/css/components/article.css","hash":"563b6fd19e1f5ba4787acd2ef2e1ee876e521cab","modified":1503080845079},{"_id":"public/css/components/categories.css","hash":"f181d27640f1408f032c5386836c4c2322724f8d","modified":1503080845079},{"_id":"public/css/components/archive.css","hash":"14902abf01556a3e23e03ac18c87fa7a5a39d89a","modified":1503080845079},{"_id":"public/css/components/footer.css","hash":"602def895fd52f288b6e93932284aa2e52b7fee0","modified":1503080845080},{"_id":"public/css/components/header.css","hash":"51f8a4c736f3b180a7c4c8f804d8060031df6a34","modified":1503080845080},{"_id":"public/css/components/layout.css","hash":"b8625c7b90a973f2e37897f346e6f80b779fd9ca","modified":1503080845080},{"_id":"public/css/components/icon.css","hash":"cdaf1a152184ff7def760f14095e4a2fa16cd6bd","modified":1503080845080},{"_id":"public/css/components/pagination.css","hash":"2f3f9bb1bc6513d08865e7a2fb2160cc47d4a229","modified":1503080845080},{"_id":"public/css/components/responsive.css","hash":"216eb94fc69007de995fc8d382670ba00a9574e8","modified":1503080845080},{"_id":"public/css/components/syntax.css","hash":"00970bfdb168aa13622c829920907ca3416829f8","modified":1503080845080},{"_id":"public/css/components/tags.css","hash":"1566e94c23ae19dbfc7d2cf433e68242ed657dea","modified":1503080845080},{"_id":"public/css/style.css","hash":"48373889a036d403ca34bc085cabeb302e2a08ee","modified":1503080845080}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"前端工程化实践","date":"2017-08-17T16:00:00.000Z","_content":"\n# 前端工程化实践\n\n![logo](bd_logo1.png)\n年初入职TalkingData，到现在半年有余，\b是时候回头看看这半年走过的路。感谢TD的充分信任和赋能，使我可以大胆尝试。部门的几条产品线，如果技术栈、规范不统一，很难保证产品的快速迭代。前端工程化属于软件工程范畴，半年中尝试了组件化开发理念、规范了 Git 工作流、Git Commit message、引入了 Airbnb 规范等很多现成的方案。\n\n整个团队，要经历从组件化到模块化，从引入开源到开源生态贡献的发展道路。\n\n## 组件化\n按设计规格制造出机器（单页应用）的零部件（组件）后，就可以快速组装出一部完整的机器。\n\n将设计稿拆分为一个个职责单一的组件，统计组件可复用的程度，然后工程师按数据开发。\n像这样从全局出发，统计拆分组件的方式，好处很明显。功能都是由单一职责的组件拼装而成。\n\n如今的前端开发，已不是简单的页面制作加上jQuery，就能满足业务要求了。前端工程师们要面对的不是简单的网站，而是更复杂的web应用。\n\n### 技术架构统一到Vue技术栈\n可以说，Vue是为组件化而生的View层框架。它为应用的组件化，提供了很好的支持，还有完善的脚手架工具可用。\n团队统一技术栈有很多好处，可以降低产品间人员调动的成本、复用组件和模块的代码。\n\n到目前为止，团队研发的大部分产品，完成了Vue的重构迁移。\n\n### 组件化开发过程\n现如今，产品更新迭代的速度，很大程度上决定了产品成败。组件化的开发理念，可以快速的拼装出产品，而且每个组件都可以独立的升级或替换。\n\n在产品正式开发之前，我们仔细研究设计图，统计出整个产品包含的组件，哪些组件可复用度更高，\n优先开发这些组件。一旦这些工作完成，就能快速拼装出产品功能页面。\n\n不难想到，前端开发的效率取决于设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。\n\n在智能数据市场产品（SDMK）的开发初期，选择了组件化的开发方式，很大的缩短了产品迭代周期。\n\n(图片制作： 页面A --- 组件A --- 页面B)\n\n\n## 源代码管理要规范化\n\n产品团队中，几位工程师分工协作，开发不同的功能组件。各功能组件相互依赖关联，只有规范化的源代码管理流程，才能避免了因多人协作，而导致的风险和保证产品的快速持续的功能集成。\n\n### 规范化 Git 工作流\n高效的开发团队，需要规范化的代码管理流程做保证，团队直接沿用了成熟的 Git 分支开发流程，并采用了每日集成的开发策略。\n\n在产品的攻坚和优化阶段，我们采用了不同的分支开发策略。\n\n在攻坚阶段，每位工程师在自己的开发分支，完成分配的功能组件。每天在固定的时间，将大家的代码 commit 到 daily 分支上，同时还会进行 CodeReview，做规范性检查和业务逻辑的优化等。\n\n在产品上线进入产品的优化阶段，这个时候大家会转换为 Feature 分支，同样会进行每天的 Daily 过程。\n\n如此，大家每天的工作目标明确、成果可见，每天都很有成就感。\n\n（图片：git工作流图）\n\n### 规范化 Git Commit message\n\n一次代码提交，应该尽量做到原子性，比如：完成了一次 Bugfix、完善某功能文档、对某个方法做了重构等。而每次代码提交，都应该提供格式化的 Commit message。\n\n格式化的 Commit message，有很多个好处：\n\n1. 提供更多的历史信息，方便代码 CodeReview。\n2. 可以过滤不同类型的 Commit，方便快速查找信息。\n3. 还可以由 Commit message 生成产品的 Changelog。\n\n在每天的 Daily 过程中，快速浏览 Gitlab 的提交记录中的 Commit message，可以高效的完成 Code Review。\n\n团队直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有现成配套的工具。\n\nAngular规范：\n```\nfeat：新功能（feature）\nfix：修补bug\ndocs：文档（documentation）\nstyle： 格式（不影响代码运行的变动）\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：构建过程或辅助工具的变动\n```\n\n（工具图片、Jenkins截图）\n\n## 代码风格的规范化\n\n阅读规范化产品的代码，最直观感受是：所有代码，要看起来像是是出自一人之手，无论功能实现，还是代码注释。\n\n在进行规范化之前，团队需要将主要开发语言迁移到 ES6。把匕首换成宝剑，提高了攻城成功的把握。\n\n### 迁移到 ES6 和 SASS\n\n过于灵活的ES5，并不适合开发企业级 Web 应用。\n\n因为产品存在历史 ES5 代码，大家需要循序渐进的完成ES6的迁移，比如：\n1. 新功能代码，禁止使用 var  关键字声明变量，而是改为使用let或const；\n2. 对于函数的声明，鼓励去掉 function 关键字，更多的使用箭头函数和使用函数的默认值；\n3. 用模版字符串替换掉之前的字符串拼接；\n\n像这样，逐渐深入更多的ES6特性。从实际效果看，各产品线代码迁移的过程十分地平滑自然。\n\n下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效：\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n在 CSS 方面，各产品统一选择了 SASS 预处理器。为 CSS 引入了，许多编程语言特性和模块化的能力。\n\n### 引入 Airbnb 的 Javascirpt 和 CSS 规范\n\n感谢 Airbnb 开源了内部的语言规范，免去了大家设计和维护规范文档的麻烦。\n\n团队采用了，目前广泛使用和成熟的 Airbnb 语言规范，有现成的规范文档和工具可用。\n\n只有工具才能约束大家的编码习惯，团队引入了 eslint 检查工具，配合 Airbnb的规范，保证了大家代码的规范性。\n\n在代码编辑和“编译”阶段，eslint 插件会自动化检查产品代码是否符合规范。对于不符合规范的代码，会抛出错误提示，阻止代码的执行。\n\n除了代码规范的约束，eslint 还为解释型的 js 带来了部分编译特性，比如：\n\n1. 项目中声明了没有用的变量、函数和语句，eslint 会给出错误提示；\n2. 代码中使用了具有一定风险的 for in 循环，也会给出修改的建议；\n\n在学习 Airbnb 规范的过程中，对照 ES5 和 ES6 的语法的不同，快速完成了语言的切换。\n\n对于 CSS 预处理器SASS，我们尝试了 stylelint 工具，配合 Airbnb 开源的 CSS 规范。但遗憾的是，社区开源的相关工具并不完善，编辑器只找到了 atom 的版本。\n\n\n## 文档的规范化\n\n工程师们大都不喜欢写文档。\n\n而实际情况是，文档的更新，一般都是滞后的。比如接口新增了参数，文档也需要做对应的修改，而这带来了一定的维护成本。\n\n### 源代码即文档\n组件和模块的设计拆分，应该要符合简单的单一职责原则。这样源代码要能够做到自解释，文件名表明一个文件的功能、方法名称解释该方法的功能等。\n\n好的文件名称、方法名称起到了文档的作用。\n\n对于接口文档，我们设计了声明式的 model 层 apischema，一个 model 的定义，就是一系列接口的文档。\n\n从代码中直观的看出接口协议、地址和参数规则：\n\n```\n// define api\nexport const addInternalGroup = schema.post('/path/to/action', {\n  name: { type: String, required: true },\n  info: { type: String, required: true },\n});\n\n// use api\naddInternalGroup({ name: 'xxx', info: 'xxx' }).then((json) => {\n  log(json);  \n});\n```\n\napischema： https://www.npmjs.com/package/apischema\n\n除了代码，团队还会有很多东西要沉淀记录，必要的文档还是要有的。\n\n### 用 markdown 写周报\n如今，除了编程语言，markdown 成为了工程师必须要掌握的硬技能。团队的周报使用 markdown 记录到 gitlab 中。\n\n### \b大前端周刊\n\n在知识分享方面，团队在每周五，收集大家读到的优秀文章，形成周刊。\n\n大前端周刊：https://talkingdata.github.io/fsd/\n\n\n## 未来展望\n\n### 从组件化到模块化\nVue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。\n每个产品都有自己的一套time-format模块，不同产品线，重复劳动太多。\n\n团队不仅仅需要组件化，我们需要将公共代码进行模块化，感谢Node社区。\n\n各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。\n\n希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。\n\n不止于业务，向前一步。\n\n在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。\n\n\n### 从前端到大前端\n\n工程师要竖立前端大局观，从不同的角度考虑技术方案。\n\n用前端的方案实现产品的灰度分流和配置。\n\n基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。\n\n### 从引入开源到开源生态共建\n产品中引入了大量的开源模块和工具：Nodejs、NPM、Webpack、Vue和iView等。遥想开始入行前端的几年，在开发业务代码之前，需要花费大量的时间和精力，开发公共组件、模块加载器和打包工具等。如今所有这些，都可以在社区找到解决方案。\n\n每一位懂得感恩的工程师，都应该参与到开源生态的共建。\n\n## 最后\n团队在前端工程化方面，还有很长的路要走。\n\n加油2017！\n","source":"_posts/前端工程化实践.md","raw":"---\ntitle: 前端工程化实践\ndate: 2017-08-18 00:00\ntags: [修订二,工程化,git,eslint]\n---\n\n# 前端工程化实践\n\n![logo](bd_logo1.png)\n年初入职TalkingData，到现在半年有余，\b是时候回头看看这半年走过的路。感谢TD的充分信任和赋能，使我可以大胆尝试。部门的几条产品线，如果技术栈、规范不统一，很难保证产品的快速迭代。前端工程化属于软件工程范畴，半年中尝试了组件化开发理念、规范了 Git 工作流、Git Commit message、引入了 Airbnb 规范等很多现成的方案。\n\n整个团队，要经历从组件化到模块化，从引入开源到开源生态贡献的发展道路。\n\n## 组件化\n按设计规格制造出机器（单页应用）的零部件（组件）后，就可以快速组装出一部完整的机器。\n\n将设计稿拆分为一个个职责单一的组件，统计组件可复用的程度，然后工程师按数据开发。\n像这样从全局出发，统计拆分组件的方式，好处很明显。功能都是由单一职责的组件拼装而成。\n\n如今的前端开发，已不是简单的页面制作加上jQuery，就能满足业务要求了。前端工程师们要面对的不是简单的网站，而是更复杂的web应用。\n\n### 技术架构统一到Vue技术栈\n可以说，Vue是为组件化而生的View层框架。它为应用的组件化，提供了很好的支持，还有完善的脚手架工具可用。\n团队统一技术栈有很多好处，可以降低产品间人员调动的成本、复用组件和模块的代码。\n\n到目前为止，团队研发的大部分产品，完成了Vue的重构迁移。\n\n### 组件化开发过程\n现如今，产品更新迭代的速度，很大程度上决定了产品成败。组件化的开发理念，可以快速的拼装出产品，而且每个组件都可以独立的升级或替换。\n\n在产品正式开发之前，我们仔细研究设计图，统计出整个产品包含的组件，哪些组件可复用度更高，\n优先开发这些组件。一旦这些工作完成，就能快速拼装出产品功能页面。\n\n不难想到，前端开发的效率取决于设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。\n\n在智能数据市场产品（SDMK）的开发初期，选择了组件化的开发方式，很大的缩短了产品迭代周期。\n\n(图片制作： 页面A --- 组件A --- 页面B)\n\n\n## 源代码管理要规范化\n\n产品团队中，几位工程师分工协作，开发不同的功能组件。各功能组件相互依赖关联，只有规范化的源代码管理流程，才能避免了因多人协作，而导致的风险和保证产品的快速持续的功能集成。\n\n### 规范化 Git 工作流\n高效的开发团队，需要规范化的代码管理流程做保证，团队直接沿用了成熟的 Git 分支开发流程，并采用了每日集成的开发策略。\n\n在产品的攻坚和优化阶段，我们采用了不同的分支开发策略。\n\n在攻坚阶段，每位工程师在自己的开发分支，完成分配的功能组件。每天在固定的时间，将大家的代码 commit 到 daily 分支上，同时还会进行 CodeReview，做规范性检查和业务逻辑的优化等。\n\n在产品上线进入产品的优化阶段，这个时候大家会转换为 Feature 分支，同样会进行每天的 Daily 过程。\n\n如此，大家每天的工作目标明确、成果可见，每天都很有成就感。\n\n（图片：git工作流图）\n\n### 规范化 Git Commit message\n\n一次代码提交，应该尽量做到原子性，比如：完成了一次 Bugfix、完善某功能文档、对某个方法做了重构等。而每次代码提交，都应该提供格式化的 Commit message。\n\n格式化的 Commit message，有很多个好处：\n\n1. 提供更多的历史信息，方便代码 CodeReview。\n2. 可以过滤不同类型的 Commit，方便快速查找信息。\n3. 还可以由 Commit message 生成产品的 Changelog。\n\n在每天的 Daily 过程中，快速浏览 Gitlab 的提交记录中的 Commit message，可以高效的完成 Code Review。\n\n团队直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有现成配套的工具。\n\nAngular规范：\n```\nfeat：新功能（feature）\nfix：修补bug\ndocs：文档（documentation）\nstyle： 格式（不影响代码运行的变动）\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：构建过程或辅助工具的变动\n```\n\n（工具图片、Jenkins截图）\n\n## 代码风格的规范化\n\n阅读规范化产品的代码，最直观感受是：所有代码，要看起来像是是出自一人之手，无论功能实现，还是代码注释。\n\n在进行规范化之前，团队需要将主要开发语言迁移到 ES6。把匕首换成宝剑，提高了攻城成功的把握。\n\n### 迁移到 ES6 和 SASS\n\n过于灵活的ES5，并不适合开发企业级 Web 应用。\n\n因为产品存在历史 ES5 代码，大家需要循序渐进的完成ES6的迁移，比如：\n1. 新功能代码，禁止使用 var  关键字声明变量，而是改为使用let或const；\n2. 对于函数的声明，鼓励去掉 function 关键字，更多的使用箭头函数和使用函数的默认值；\n3. 用模版字符串替换掉之前的字符串拼接；\n\n像这样，逐渐深入更多的ES6特性。从实际效果看，各产品线代码迁移的过程十分地平滑自然。\n\n下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效：\n\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n在 CSS 方面，各产品统一选择了 SASS 预处理器。为 CSS 引入了，许多编程语言特性和模块化的能力。\n\n### 引入 Airbnb 的 Javascirpt 和 CSS 规范\n\n感谢 Airbnb 开源了内部的语言规范，免去了大家设计和维护规范文档的麻烦。\n\n团队采用了，目前广泛使用和成熟的 Airbnb 语言规范，有现成的规范文档和工具可用。\n\n只有工具才能约束大家的编码习惯，团队引入了 eslint 检查工具，配合 Airbnb的规范，保证了大家代码的规范性。\n\n在代码编辑和“编译”阶段，eslint 插件会自动化检查产品代码是否符合规范。对于不符合规范的代码，会抛出错误提示，阻止代码的执行。\n\n除了代码规范的约束，eslint 还为解释型的 js 带来了部分编译特性，比如：\n\n1. 项目中声明了没有用的变量、函数和语句，eslint 会给出错误提示；\n2. 代码中使用了具有一定风险的 for in 循环，也会给出修改的建议；\n\n在学习 Airbnb 规范的过程中，对照 ES5 和 ES6 的语法的不同，快速完成了语言的切换。\n\n对于 CSS 预处理器SASS，我们尝试了 stylelint 工具，配合 Airbnb 开源的 CSS 规范。但遗憾的是，社区开源的相关工具并不完善，编辑器只找到了 atom 的版本。\n\n\n## 文档的规范化\n\n工程师们大都不喜欢写文档。\n\n而实际情况是，文档的更新，一般都是滞后的。比如接口新增了参数，文档也需要做对应的修改，而这带来了一定的维护成本。\n\n### 源代码即文档\n组件和模块的设计拆分，应该要符合简单的单一职责原则。这样源代码要能够做到自解释，文件名表明一个文件的功能、方法名称解释该方法的功能等。\n\n好的文件名称、方法名称起到了文档的作用。\n\n对于接口文档，我们设计了声明式的 model 层 apischema，一个 model 的定义，就是一系列接口的文档。\n\n从代码中直观的看出接口协议、地址和参数规则：\n\n```\n// define api\nexport const addInternalGroup = schema.post('/path/to/action', {\n  name: { type: String, required: true },\n  info: { type: String, required: true },\n});\n\n// use api\naddInternalGroup({ name: 'xxx', info: 'xxx' }).then((json) => {\n  log(json);  \n});\n```\n\napischema： https://www.npmjs.com/package/apischema\n\n除了代码，团队还会有很多东西要沉淀记录，必要的文档还是要有的。\n\n### 用 markdown 写周报\n如今，除了编程语言，markdown 成为了工程师必须要掌握的硬技能。团队的周报使用 markdown 记录到 gitlab 中。\n\n### \b大前端周刊\n\n在知识分享方面，团队在每周五，收集大家读到的优秀文章，形成周刊。\n\n大前端周刊：https://talkingdata.github.io/fsd/\n\n\n## 未来展望\n\n### 从组件化到模块化\nVue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。\n每个产品都有自己的一套time-format模块，不同产品线，重复劳动太多。\n\n团队不仅仅需要组件化，我们需要将公共代码进行模块化，感谢Node社区。\n\n各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。\n\n希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。\n\n不止于业务，向前一步。\n\n在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。\n\n\n### 从前端到大前端\n\n工程师要竖立前端大局观，从不同的角度考虑技术方案。\n\n用前端的方案实现产品的灰度分流和配置。\n\n基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。\n\n### 从引入开源到开源生态共建\n产品中引入了大量的开源模块和工具：Nodejs、NPM、Webpack、Vue和iView等。遥想开始入行前端的几年，在开发业务代码之前，需要花费大量的时间和精力，开发公共组件、模块加载器和打包工具等。如今所有这些，都可以在社区找到解决方案。\n\n每一位懂得感恩的工程师，都应该参与到开源生态的共建。\n\n## 最后\n团队在前端工程化方面，还有很长的路要走。\n\n加油2017！\n","slug":"前端工程化实践","published":1,"updated":"2017-08-18T18:25:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i7iy2z00003qtxs1a8ppkp","content":"<h1 id=\"前端工程化实践\"><a href=\"#前端工程化实践\" class=\"headerlink\" title=\"前端工程化实践\"></a>前端工程化实践</h1><p><img src=\"/2017/08/18/前端工程化实践/bd_logo1.png\" alt=\"logo\"><br>年初入职TalkingData，到现在半年有余，\b是时候回头看看这半年走过的路。感谢TD的充分信任和赋能，使我可以大胆尝试。部门的几条产品线，如果技术栈、规范不统一，很难保证产品的快速迭代。前端工程化属于软件工程范畴，半年中尝试了组件化开发理念、规范了 Git 工作流、Git Commit message、引入了 Airbnb 规范等很多现成的方案。</p>\n<p>整个团队，要经历从组件化到模块化，从引入开源到开源生态贡献的发展道路。</p>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><p>按设计规格制造出机器（单页应用）的零部件（组件）后，就可以快速组装出一部完整的机器。</p>\n<p>将设计稿拆分为一个个职责单一的组件，统计组件可复用的程度，然后工程师按数据开发。<br>像这样从全局出发，统计拆分组件的方式，好处很明显。功能都是由单一职责的组件拼装而成。</p>\n<p>如今的前端开发，已不是简单的页面制作加上jQuery，就能满足业务要求了。前端工程师们要面对的不是简单的网站，而是更复杂的web应用。</p>\n<h3 id=\"技术架构统一到Vue技术栈\"><a href=\"#技术架构统一到Vue技术栈\" class=\"headerlink\" title=\"技术架构统一到Vue技术栈\"></a>技术架构统一到Vue技术栈</h3><p>可以说，Vue是为组件化而生的View层框架。它为应用的组件化，提供了很好的支持，还有完善的脚手架工具可用。<br>团队统一技术栈有很多好处，可以降低产品间人员调动的成本、复用组件和模块的代码。</p>\n<p>到目前为止，团队研发的大部分产品，完成了Vue的重构迁移。</p>\n<h3 id=\"组件化开发过程\"><a href=\"#组件化开发过程\" class=\"headerlink\" title=\"组件化开发过程\"></a>组件化开发过程</h3><p>现如今，产品更新迭代的速度，很大程度上决定了产品成败。组件化的开发理念，可以快速的拼装出产品，而且每个组件都可以独立的升级或替换。</p>\n<p>在产品正式开发之前，我们仔细研究设计图，统计出整个产品包含的组件，哪些组件可复用度更高，<br>优先开发这些组件。一旦这些工作完成，就能快速拼装出产品功能页面。</p>\n<p>不难想到，前端开发的效率取决于设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。</p>\n<p>在智能数据市场产品（SDMK）的开发初期，选择了组件化的开发方式，很大的缩短了产品迭代周期。</p>\n<p>(图片制作： 页面A — 组件A — 页面B)</p>\n<h2 id=\"源代码管理要规范化\"><a href=\"#源代码管理要规范化\" class=\"headerlink\" title=\"源代码管理要规范化\"></a>源代码管理要规范化</h2><p>产品团队中，几位工程师分工协作，开发不同的功能组件。各功能组件相互依赖关联，只有规范化的源代码管理流程，才能避免了因多人协作，而导致的风险和保证产品的快速持续的功能集成。</p>\n<h3 id=\"规范化-Git-工作流\"><a href=\"#规范化-Git-工作流\" class=\"headerlink\" title=\"规范化 Git 工作流\"></a>规范化 Git 工作流</h3><p>高效的开发团队，需要规范化的代码管理流程做保证，团队直接沿用了成熟的 Git 分支开发流程，并采用了每日集成的开发策略。</p>\n<p>在产品的攻坚和优化阶段，我们采用了不同的分支开发策略。</p>\n<p>在攻坚阶段，每位工程师在自己的开发分支，完成分配的功能组件。每天在固定的时间，将大家的代码 commit 到 daily 分支上，同时还会进行 CodeReview，做规范性检查和业务逻辑的优化等。</p>\n<p>在产品上线进入产品的优化阶段，这个时候大家会转换为 Feature 分支，同样会进行每天的 Daily 过程。</p>\n<p>如此，大家每天的工作目标明确、成果可见，每天都很有成就感。</p>\n<p>（图片：git工作流图）</p>\n<h3 id=\"规范化-Git-Commit-message\"><a href=\"#规范化-Git-Commit-message\" class=\"headerlink\" title=\"规范化 Git Commit message\"></a>规范化 Git Commit message</h3><p>一次代码提交，应该尽量做到原子性，比如：完成了一次 Bugfix、完善某功能文档、对某个方法做了重构等。而每次代码提交，都应该提供格式化的 Commit message。</p>\n<p>格式化的 Commit message，有很多个好处：</p>\n<ol>\n<li>提供更多的历史信息，方便代码 CodeReview。</li>\n<li>可以过滤不同类型的 Commit，方便快速查找信息。</li>\n<li>还可以由 Commit message 生成产品的 Changelog。</li>\n</ol>\n<p>在每天的 Daily 过程中，快速浏览 Gitlab 的提交记录中的 Commit message，可以高效的完成 Code Review。</p>\n<p>团队直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有现成配套的工具。</p>\n<p>Angular规范：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">feat：新功能（feature）</div><div class=\"line\">fix：修补bug</div><div class=\"line\">docs：文档（documentation）</div><div class=\"line\">style： 格式（不影响代码运行的变动）</div><div class=\"line\">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</div><div class=\"line\">test：增加测试</div><div class=\"line\">chore：构建过程或辅助工具的变动</div></pre></td></tr></table></figure></p>\n<p>（工具图片、Jenkins截图）</p>\n<h2 id=\"代码风格的规范化\"><a href=\"#代码风格的规范化\" class=\"headerlink\" title=\"代码风格的规范化\"></a>代码风格的规范化</h2><p>阅读规范化产品的代码，最直观感受是：所有代码，要看起来像是是出自一人之手，无论功能实现，还是代码注释。</p>\n<p>在进行规范化之前，团队需要将主要开发语言迁移到 ES6。把匕首换成宝剑，提高了攻城成功的把握。</p>\n<h3 id=\"迁移到-ES6-和-SASS\"><a href=\"#迁移到-ES6-和-SASS\" class=\"headerlink\" title=\"迁移到 ES6 和 SASS\"></a>迁移到 ES6 和 SASS</h3><p>过于灵活的ES5，并不适合开发企业级 Web 应用。</p>\n<p>因为产品存在历史 ES5 代码，大家需要循序渐进的完成ES6的迁移，比如：</p>\n<ol>\n<li>新功能代码，禁止使用 var  关键字声明变量，而是改为使用let或const；</li>\n<li>对于函数的声明，鼓励去掉 function 关键字，更多的使用箭头函数和使用函数的默认值；</li>\n<li>用模版字符串替换掉之前的字符串拼接；</li>\n</ol>\n<p>像这样，逐渐深入更多的ES6特性。从实际效果看，各产品线代码迁移的过程十分地平滑自然。</p>\n<p>下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\"><span class=\"keyword\">const</span> len = items.length;</div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [];</div><div class=\"line\"><span class=\"keyword\">let</span> i;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">  itemsCopy[i] = items[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>\n<p>在 CSS 方面，各产品统一选择了 SASS 预处理器。为 CSS 引入了，许多编程语言特性和模块化的能力。</p>\n<h3 id=\"引入-Airbnb-的-Javascirpt-和-CSS-规范\"><a href=\"#引入-Airbnb-的-Javascirpt-和-CSS-规范\" class=\"headerlink\" title=\"引入 Airbnb 的 Javascirpt 和 CSS 规范\"></a>引入 Airbnb 的 Javascirpt 和 CSS 规范</h3><p>感谢 Airbnb 开源了内部的语言规范，免去了大家设计和维护规范文档的麻烦。</p>\n<p>团队采用了，目前广泛使用和成熟的 Airbnb 语言规范，有现成的规范文档和工具可用。</p>\n<p>只有工具才能约束大家的编码习惯，团队引入了 eslint 检查工具，配合 Airbnb的规范，保证了大家代码的规范性。</p>\n<p>在代码编辑和“编译”阶段，eslint 插件会自动化检查产品代码是否符合规范。对于不符合规范的代码，会抛出错误提示，阻止代码的执行。</p>\n<p>除了代码规范的约束，eslint 还为解释型的 js 带来了部分编译特性，比如：</p>\n<ol>\n<li>项目中声明了没有用的变量、函数和语句，eslint 会给出错误提示；</li>\n<li>代码中使用了具有一定风险的 for in 循环，也会给出修改的建议；</li>\n</ol>\n<p>在学习 Airbnb 规范的过程中，对照 ES5 和 ES6 的语法的不同，快速完成了语言的切换。</p>\n<p>对于 CSS 预处理器SASS，我们尝试了 stylelint 工具，配合 Airbnb 开源的 CSS 规范。但遗憾的是，社区开源的相关工具并不完善，编辑器只找到了 atom 的版本。</p>\n<h2 id=\"文档的规范化\"><a href=\"#文档的规范化\" class=\"headerlink\" title=\"文档的规范化\"></a>文档的规范化</h2><p>工程师们大都不喜欢写文档。</p>\n<p>而实际情况是，文档的更新，一般都是滞后的。比如接口新增了参数，文档也需要做对应的修改，而这带来了一定的维护成本。</p>\n<h3 id=\"源代码即文档\"><a href=\"#源代码即文档\" class=\"headerlink\" title=\"源代码即文档\"></a>源代码即文档</h3><p>组件和模块的设计拆分，应该要符合简单的单一职责原则。这样源代码要能够做到自解释，文件名表明一个文件的功能、方法名称解释该方法的功能等。</p>\n<p>好的文件名称、方法名称起到了文档的作用。</p>\n<p>对于接口文档，我们设计了声明式的 model 层 apischema，一个 model 的定义，就是一系列接口的文档。</p>\n<p>从代码中直观的看出接口协议、地址和参数规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// define api</div><div class=\"line\">export const addInternalGroup = schema.post(&apos;/path/to/action&apos;, &#123;</div><div class=\"line\">  name: &#123; type: String, required: true &#125;,</div><div class=\"line\">  info: &#123; type: String, required: true &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// use api</div><div class=\"line\">addInternalGroup(&#123; name: &apos;xxx&apos;, info: &apos;xxx&apos; &#125;).then((json) =&gt; &#123;</div><div class=\"line\">  log(json);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>apischema： <a href=\"https://www.npmjs.com/package/apischema\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/apischema</a></p>\n<p>除了代码，团队还会有很多东西要沉淀记录，必要的文档还是要有的。</p>\n<h3 id=\"用-markdown-写周报\"><a href=\"#用-markdown-写周报\" class=\"headerlink\" title=\"用 markdown 写周报\"></a>用 markdown 写周报</h3><p>如今，除了编程语言，markdown 成为了工程师必须要掌握的硬技能。团队的周报使用 markdown 记录到 gitlab 中。</p>\n<h3 id=\"大前端周刊\"><a href=\"#大前端周刊\" class=\"headerlink\" title=\"\b大前端周刊\"></a>\b大前端周刊</h3><p>在知识分享方面，团队在每周五，收集大家读到的优秀文章，形成周刊。</p>\n<p>大前端周刊：<a href=\"https://talkingdata.github.io/fsd/\" target=\"_blank\" rel=\"external\">https://talkingdata.github.io/fsd/</a></p>\n<h2 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h2><h3 id=\"从组件化到模块化\"><a href=\"#从组件化到模块化\" class=\"headerlink\" title=\"从组件化到模块化\"></a>从组件化到模块化</h3><p>Vue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。<br>每个产品都有自己的一套time-format模块，不同产品线，重复劳动太多。</p>\n<p>团队不仅仅需要组件化，我们需要将公共代码进行模块化，感谢Node社区。</p>\n<p>各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。</p>\n<p>希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。</p>\n<p>不止于业务，向前一步。</p>\n<p>在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。</p>\n<h3 id=\"从前端到大前端\"><a href=\"#从前端到大前端\" class=\"headerlink\" title=\"从前端到大前端\"></a>从前端到大前端</h3><p>工程师要竖立前端大局观，从不同的角度考虑技术方案。</p>\n<p>用前端的方案实现产品的灰度分流和配置。</p>\n<p>基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。</p>\n<h3 id=\"从引入开源到开源生态共建\"><a href=\"#从引入开源到开源生态共建\" class=\"headerlink\" title=\"从引入开源到开源生态共建\"></a>从引入开源到开源生态共建</h3><p>产品中引入了大量的开源模块和工具：Nodejs、NPM、Webpack、Vue和iView等。遥想开始入行前端的几年，在开发业务代码之前，需要花费大量的时间和精力，开发公共组件、模块加载器和打包工具等。如今所有这些，都可以在社区找到解决方案。</p>\n<p>每一位懂得感恩的工程师，都应该参与到开源生态的共建。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>团队在前端工程化方面，还有很长的路要走。</p>\n<p>加油2017！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端工程化实践\"><a href=\"#前端工程化实践\" class=\"headerlink\" title=\"前端工程化实践\"></a>前端工程化实践</h1><p><img src=\"/2017/08/18/前端工程化实践/bd_logo1.png\" alt=\"logo\"><br>年初入职TalkingData，到现在半年有余，\b是时候回头看看这半年走过的路。感谢TD的充分信任和赋能，使我可以大胆尝试。部门的几条产品线，如果技术栈、规范不统一，很难保证产品的快速迭代。前端工程化属于软件工程范畴，半年中尝试了组件化开发理念、规范了 Git 工作流、Git Commit message、引入了 Airbnb 规范等很多现成的方案。</p>\n<p>整个团队，要经历从组件化到模块化，从引入开源到开源生态贡献的发展道路。</p>\n<h2 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h2><p>按设计规格制造出机器（单页应用）的零部件（组件）后，就可以快速组装出一部完整的机器。</p>\n<p>将设计稿拆分为一个个职责单一的组件，统计组件可复用的程度，然后工程师按数据开发。<br>像这样从全局出发，统计拆分组件的方式，好处很明显。功能都是由单一职责的组件拼装而成。</p>\n<p>如今的前端开发，已不是简单的页面制作加上jQuery，就能满足业务要求了。前端工程师们要面对的不是简单的网站，而是更复杂的web应用。</p>\n<h3 id=\"技术架构统一到Vue技术栈\"><a href=\"#技术架构统一到Vue技术栈\" class=\"headerlink\" title=\"技术架构统一到Vue技术栈\"></a>技术架构统一到Vue技术栈</h3><p>可以说，Vue是为组件化而生的View层框架。它为应用的组件化，提供了很好的支持，还有完善的脚手架工具可用。<br>团队统一技术栈有很多好处，可以降低产品间人员调动的成本、复用组件和模块的代码。</p>\n<p>到目前为止，团队研发的大部分产品，完成了Vue的重构迁移。</p>\n<h3 id=\"组件化开发过程\"><a href=\"#组件化开发过程\" class=\"headerlink\" title=\"组件化开发过程\"></a>组件化开发过程</h3><p>现如今，产品更新迭代的速度，很大程度上决定了产品成败。组件化的开发理念，可以快速的拼装出产品，而且每个组件都可以独立的升级或替换。</p>\n<p>在产品正式开发之前，我们仔细研究设计图，统计出整个产品包含的组件，哪些组件可复用度更高，<br>优先开发这些组件。一旦这些工作完成，就能快速拼装出产品功能页面。</p>\n<p>不难想到，前端开发的效率取决于设计稿的完整度，设计师提供的设计稿越完整，前端工程师的开发效率会越高。</p>\n<p>在智能数据市场产品（SDMK）的开发初期，选择了组件化的开发方式，很大的缩短了产品迭代周期。</p>\n<p>(图片制作： 页面A — 组件A — 页面B)</p>\n<h2 id=\"源代码管理要规范化\"><a href=\"#源代码管理要规范化\" class=\"headerlink\" title=\"源代码管理要规范化\"></a>源代码管理要规范化</h2><p>产品团队中，几位工程师分工协作，开发不同的功能组件。各功能组件相互依赖关联，只有规范化的源代码管理流程，才能避免了因多人协作，而导致的风险和保证产品的快速持续的功能集成。</p>\n<h3 id=\"规范化-Git-工作流\"><a href=\"#规范化-Git-工作流\" class=\"headerlink\" title=\"规范化 Git 工作流\"></a>规范化 Git 工作流</h3><p>高效的开发团队，需要规范化的代码管理流程做保证，团队直接沿用了成熟的 Git 分支开发流程，并采用了每日集成的开发策略。</p>\n<p>在产品的攻坚和优化阶段，我们采用了不同的分支开发策略。</p>\n<p>在攻坚阶段，每位工程师在自己的开发分支，完成分配的功能组件。每天在固定的时间，将大家的代码 commit 到 daily 分支上，同时还会进行 CodeReview，做规范性检查和业务逻辑的优化等。</p>\n<p>在产品上线进入产品的优化阶段，这个时候大家会转换为 Feature 分支，同样会进行每天的 Daily 过程。</p>\n<p>如此，大家每天的工作目标明确、成果可见，每天都很有成就感。</p>\n<p>（图片：git工作流图）</p>\n<h3 id=\"规范化-Git-Commit-message\"><a href=\"#规范化-Git-Commit-message\" class=\"headerlink\" title=\"规范化 Git Commit message\"></a>规范化 Git Commit message</h3><p>一次代码提交，应该尽量做到原子性，比如：完成了一次 Bugfix、完善某功能文档、对某个方法做了重构等。而每次代码提交，都应该提供格式化的 Commit message。</p>\n<p>格式化的 Commit message，有很多个好处：</p>\n<ol>\n<li>提供更多的历史信息，方便代码 CodeReview。</li>\n<li>可以过滤不同类型的 Commit，方便快速查找信息。</li>\n<li>还可以由 Commit message 生成产品的 Changelog。</li>\n</ol>\n<p>在每天的 Daily 过程中，快速浏览 Gitlab 的提交记录中的 Commit message，可以高效的完成 Code Review。</p>\n<p>团队直接引入了广泛使用的Angular提交规范，比较合理和系统化，并且有现成配套的工具。</p>\n<p>Angular规范：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">feat：新功能（feature）</div><div class=\"line\">fix：修补bug</div><div class=\"line\">docs：文档（documentation）</div><div class=\"line\">style： 格式（不影响代码运行的变动）</div><div class=\"line\">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</div><div class=\"line\">test：增加测试</div><div class=\"line\">chore：构建过程或辅助工具的变动</div></pre></td></tr></table></figure></p>\n<p>（工具图片、Jenkins截图）</p>\n<h2 id=\"代码风格的规范化\"><a href=\"#代码风格的规范化\" class=\"headerlink\" title=\"代码风格的规范化\"></a>代码风格的规范化</h2><p>阅读规范化产品的代码，最直观感受是：所有代码，要看起来像是是出自一人之手，无论功能实现，还是代码注释。</p>\n<p>在进行规范化之前，团队需要将主要开发语言迁移到 ES6。把匕首换成宝剑，提高了攻城成功的把握。</p>\n<h3 id=\"迁移到-ES6-和-SASS\"><a href=\"#迁移到-ES6-和-SASS\" class=\"headerlink\" title=\"迁移到 ES6 和 SASS\"></a>迁移到 ES6 和 SASS</h3><p>过于灵活的ES5，并不适合开发企业级 Web 应用。</p>\n<p>因为产品存在历史 ES5 代码，大家需要循序渐进的完成ES6的迁移，比如：</p>\n<ol>\n<li>新功能代码，禁止使用 var  关键字声明变量，而是改为使用let或const；</li>\n<li>对于函数的声明，鼓励去掉 function 关键字，更多的使用箭头函数和使用函数的默认值；</li>\n<li>用模版字符串替换掉之前的字符串拼接；</li>\n</ol>\n<p>像这样，逐渐深入更多的ES6特性。从实际效果看，各产品线代码迁移的过程十分地平滑自然。</p>\n<p>下面一段代码示例，实现数据的复制，可以发现ES6代码会更简洁高效：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// bad</span></div><div class=\"line\"><span class=\"keyword\">const</span> len = items.length;</div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [];</div><div class=\"line\"><span class=\"keyword\">let</span> i;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">  itemsCopy[i] = items[i];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// good</span></div><div class=\"line\"><span class=\"keyword\">const</span> itemsCopy = [...items];</div></pre></td></tr></table></figure>\n<p>在 CSS 方面，各产品统一选择了 SASS 预处理器。为 CSS 引入了，许多编程语言特性和模块化的能力。</p>\n<h3 id=\"引入-Airbnb-的-Javascirpt-和-CSS-规范\"><a href=\"#引入-Airbnb-的-Javascirpt-和-CSS-规范\" class=\"headerlink\" title=\"引入 Airbnb 的 Javascirpt 和 CSS 规范\"></a>引入 Airbnb 的 Javascirpt 和 CSS 规范</h3><p>感谢 Airbnb 开源了内部的语言规范，免去了大家设计和维护规范文档的麻烦。</p>\n<p>团队采用了，目前广泛使用和成熟的 Airbnb 语言规范，有现成的规范文档和工具可用。</p>\n<p>只有工具才能约束大家的编码习惯，团队引入了 eslint 检查工具，配合 Airbnb的规范，保证了大家代码的规范性。</p>\n<p>在代码编辑和“编译”阶段，eslint 插件会自动化检查产品代码是否符合规范。对于不符合规范的代码，会抛出错误提示，阻止代码的执行。</p>\n<p>除了代码规范的约束，eslint 还为解释型的 js 带来了部分编译特性，比如：</p>\n<ol>\n<li>项目中声明了没有用的变量、函数和语句，eslint 会给出错误提示；</li>\n<li>代码中使用了具有一定风险的 for in 循环，也会给出修改的建议；</li>\n</ol>\n<p>在学习 Airbnb 规范的过程中，对照 ES5 和 ES6 的语法的不同，快速完成了语言的切换。</p>\n<p>对于 CSS 预处理器SASS，我们尝试了 stylelint 工具，配合 Airbnb 开源的 CSS 规范。但遗憾的是，社区开源的相关工具并不完善，编辑器只找到了 atom 的版本。</p>\n<h2 id=\"文档的规范化\"><a href=\"#文档的规范化\" class=\"headerlink\" title=\"文档的规范化\"></a>文档的规范化</h2><p>工程师们大都不喜欢写文档。</p>\n<p>而实际情况是，文档的更新，一般都是滞后的。比如接口新增了参数，文档也需要做对应的修改，而这带来了一定的维护成本。</p>\n<h3 id=\"源代码即文档\"><a href=\"#源代码即文档\" class=\"headerlink\" title=\"源代码即文档\"></a>源代码即文档</h3><p>组件和模块的设计拆分，应该要符合简单的单一职责原则。这样源代码要能够做到自解释，文件名表明一个文件的功能、方法名称解释该方法的功能等。</p>\n<p>好的文件名称、方法名称起到了文档的作用。</p>\n<p>对于接口文档，我们设计了声明式的 model 层 apischema，一个 model 的定义，就是一系列接口的文档。</p>\n<p>从代码中直观的看出接口协议、地址和参数规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// define api</div><div class=\"line\">export const addInternalGroup = schema.post(&apos;/path/to/action&apos;, &#123;</div><div class=\"line\">  name: &#123; type: String, required: true &#125;,</div><div class=\"line\">  info: &#123; type: String, required: true &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// use api</div><div class=\"line\">addInternalGroup(&#123; name: &apos;xxx&apos;, info: &apos;xxx&apos; &#125;).then((json) =&gt; &#123;</div><div class=\"line\">  log(json);  </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>apischema： <a href=\"https://www.npmjs.com/package/apischema\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/package/apischema</a></p>\n<p>除了代码，团队还会有很多东西要沉淀记录，必要的文档还是要有的。</p>\n<h3 id=\"用-markdown-写周报\"><a href=\"#用-markdown-写周报\" class=\"headerlink\" title=\"用 markdown 写周报\"></a>用 markdown 写周报</h3><p>如今，除了编程语言，markdown 成为了工程师必须要掌握的硬技能。团队的周报使用 markdown 记录到 gitlab 中。</p>\n<h3 id=\"大前端周刊\"><a href=\"#大前端周刊\" class=\"headerlink\" title=\"\b大前端周刊\"></a>\b大前端周刊</h3><p>在知识分享方面，团队在每周五，收集大家读到的优秀文章，形成周刊。</p>\n<p>大前端周刊：<a href=\"https://talkingdata.github.io/fsd/\" target=\"_blank\" rel=\"external\">https://talkingdata.github.io/fsd/</a></p>\n<h2 id=\"未来展望\"><a href=\"#未来展望\" class=\"headerlink\" title=\"未来展望\"></a>未来展望</h2><h3 id=\"从组件化到模块化\"><a href=\"#从组件化到模块化\" class=\"headerlink\" title=\"从组件化到模块化\"></a>从组件化到模块化</h3><p>Vue的组件化能力，极大的缩短了产品开发周期，但回顾过去产品间的代码复用是不够的。<br>每个产品都有自己的一套time-format模块，不同产品线，重复劳动太多。</p>\n<p>团队不仅仅需要组件化，我们需要将公共代码进行模块化，感谢Node社区。</p>\n<p>各个产品引入了iView，减少了很多重复的劳动，为大家竖立了榜样。</p>\n<p>希望团队成员都适度参与到开源社区的贡献，大家都是前端生态的一部分。</p>\n<p>不止于业务，向前一步。</p>\n<p>在完成功能开发后，多一些思考，想一下开发的功能其他开发者是不是有可能会用到。</p>\n<h3 id=\"从前端到大前端\"><a href=\"#从前端到大前端\" class=\"headerlink\" title=\"从前端到大前端\"></a>从前端到大前端</h3><p>工程师要竖立前端大局观，从不同的角度考虑技术方案。</p>\n<p>用前端的方案实现产品的灰度分流和配置。</p>\n<p>基于koa2开源企业级Node解决方案Flclover，目前稳定在0.7.x版本，已经在内部两个项目完成了验证。</p>\n<h3 id=\"从引入开源到开源生态共建\"><a href=\"#从引入开源到开源生态共建\" class=\"headerlink\" title=\"从引入开源到开源生态共建\"></a>从引入开源到开源生态共建</h3><p>产品中引入了大量的开源模块和工具：Nodejs、NPM、Webpack、Vue和iView等。遥想开始入行前端的几年，在开发业务代码之前，需要花费大量的时间和精力，开发公共组件、模块加载器和打包工具等。如今所有这些，都可以在社区找到解决方案。</p>\n<p>每一位懂得感恩的工程师，都应该参与到开源生态的共建。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>团队在前端工程化方面，还有很长的路要走。</p>\n<p>加油2017！</p>\n"},{"title":"渐进式全栈开发策略","date":"2017-06-16T03:18:25.000Z","_content":"\n渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。\n\n这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。\n\n最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。\n\n可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。\n\n原则上，在开发过程中应该尽量做到：\n1. 同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；\n2. 开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。\n3. 在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。\n\n\n前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：[语义化版本](http://semver.org/lang/zh-CN/)，[package.json规则](https://docs.npmjs.com/files/package.json)、[单元测试](https://mochajs.org/)、npm组件发布等等。\n\n但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。\n","source":"_posts/渐进式全栈开发策略.md","raw":"---\ntitle: 渐进式全栈开发策略\ndate: 2017-06-16 11:18:25\ntags: [全栈,Node]\n---\n\n渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。\n\n这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。\n\n最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。\n\n可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。\n\n原则上，在开发过程中应该尽量做到：\n1. 同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；\n2. 开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。\n3. 在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。\n\n\n前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：[语义化版本](http://semver.org/lang/zh-CN/)，[package.json规则](https://docs.npmjs.com/files/package.json)、[单元测试](https://mochajs.org/)、npm组件发布等等。\n\n但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。\n","slug":"渐进式全栈开发策略","published":1,"updated":"2017-06-22T10:08:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6i7iy3400013qtxzbogp06g","content":"<p>渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。</p>\n<p>这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。</p>\n<p>最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。</p>\n<p>可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。</p>\n<p>原则上，在开发过程中应该尽量做到：</p>\n<ol>\n<li>同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；</li>\n<li>开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。</li>\n<li>在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。</li>\n</ol>\n<p>前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本</a>，<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a>、<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">单元测试</a>、npm组件发布等等。</p>\n<p>但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>渐进式开发是将具体业务代码逐渐抽象为公共组件的过程，比如要开发一个显示页面浏览量（PV）的图表功能，最终可以抽象为一个折线图组件。</p>\n<p>这个组件，可以用在所有需要折线图的功能上。组件化可以做到跨项目或团队的代码复用，可以很大程度上提高开发效率。</p>\n<p>最简单的抽象过程，是将项目中的工具类函数抽离为组件，添加对应的单元测试。将代码托管到github，并发布到npm或私有npm里。</p>\n<p>可以想象，在开发过程中会不断的重构代码的设计，保证一定的稳定性是前提条件。所以需要完善的单元测试。</p>\n<p>原则上，在开发过程中应该尽量做到：</p>\n<ol>\n<li>同一段代码不应该多次出现，复制粘贴代码会导致维护性灾难；</li>\n<li>开发一个功能前，可以先调研下npm仓库里是否有满足要求的组件，比如加密解密、日期格式化等等。</li>\n<li>在项目中，功能文件应该符合单一职责原则，过多的职责会导致代码的维护性变差。</li>\n</ol>\n<p>前端渐进式开发，可以很大程度上提高生产效率，但前提是需要一定的知识全面性，比如要了解：<a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"external\">语义化版本</a>，<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"external\">package.json规则</a>、<a href=\"https://mochajs.org/\" target=\"_blank\" rel=\"external\">单元测试</a>、npm组件发布等等。</p>\n<p>但是，放任开源会带来一些业务代码泄漏的风险。整个过程需要大家在遵循一定的规则下进行，要适度开放。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj6i7iy2z00003qtxs1a8ppkp","tag_id":"cj6i7iy3600023qtxdgoghk4o","_id":"cj6i7iy3e00073qtxr92pvvkm"},{"post_id":"cj6i7iy2z00003qtxs1a8ppkp","tag_id":"cj6i7iy3a00033qtx4tldbrhd","_id":"cj6i7iy3f00083qtxfeal4esu"},{"post_id":"cj6i7iy2z00003qtxs1a8ppkp","tag_id":"cj6i7iy3b00043qtxeiwxps27","_id":"cj6i7iy3g000a3qtx3tdvbpkf"},{"post_id":"cj6i7iy2z00003qtxs1a8ppkp","tag_id":"cj6i7iy3c00053qtxczzha3fy","_id":"cj6i7iy3g000b3qtx22lrzbn3"},{"post_id":"cj6i7iy3400013qtxzbogp06g","tag_id":"cj6i7iy3d00063qtx2nluuj95","_id":"cj6i7iy3h000c3qtx3nhihy1i"},{"post_id":"cj6i7iy3400013qtxzbogp06g","tag_id":"cj6i7iy3f00093qtxvr25qx8t","_id":"cj6i7iy3h000d3qtxe9hncpt2"}],"Tag":[{"name":"修订二","_id":"cj6i7iy3600023qtxdgoghk4o"},{"name":"工程化","_id":"cj6i7iy3a00033qtx4tldbrhd"},{"name":"git","_id":"cj6i7iy3b00043qtxeiwxps27"},{"name":"eslint","_id":"cj6i7iy3c00053qtxczzha3fy"},{"name":"全栈","_id":"cj6i7iy3d00063qtx2nluuj95"},{"name":"Node","_id":"cj6i7iy3f00093qtxvr25qx8t"}]}}